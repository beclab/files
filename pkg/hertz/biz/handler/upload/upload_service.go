// Code generated by hertz generator.

package upload

import (
	"bytes"
	"context"
	"encoding/json"
	"files/pkg/common"
	"files/pkg/drivers"
	"files/pkg/drivers/base"
	upload "files/pkg/hertz/biz/model/upload"
	"files/pkg/models"
	"fmt"
	"io"
	"net/http"
	"reflect"
	"strings"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"k8s.io/klog/v2"
)

// UploadLinkMethod .
// @router /upload/upload_link [GET]
func UploadLinkMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var req upload.UploadLinkReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	var uploadArg = &models.FileUploadArgs{
		FileParam: &models.FileParam{},
		Node:      c.Param("node"),
		From:      req.From,
		Share:     req.Share,
		ShareType: req.Sharetype,
		ShareBy:   req.Shareby,
	}

	p := req.FilePath
	if !strings.HasSuffix(p, "/") {
		p = p + "/"
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	fileParam, err := models.CreateFileParam(owner, p)
	if err != nil {
		klog.Errorf("file param error: %v, owner: %s", err, owner)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("file param error: %v", err)})
		return
	}

	uploadArg.FileParam = fileParam

	if req.Share == "1" {
		uploadArg.FileParam.Owner = req.Shareby
	}

	var handlerParam = &base.HandlerParam{
		Ctx:   ctx,
		Owner: uploadArg.FileParam.Owner,
	}
	var fileHandler = drivers.Adaptor.NewFileHandler(uploadArg.FileParam.FileType, handlerParam)
	if fileHandler == nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("handler not found, type: %s", uploadArg.FileParam.FileType)})
		return
	}
	resp, err := fileHandler.UploadLink(uploadArg)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{
			"code":    1,
			"message": err.Error(),
		})
		return
	}
	c.String(consts.StatusOK, string(resp))
}

// UploadedBytesMethod .
// @router /upload/file_uploaded_bytes [GET]
func UploadedBytesMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var req upload.UploadedBytesReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	var uploadArg = &models.FileUploadArgs{
		FileParam:     &models.FileParam{},
		Node:          c.Param("node"),
		Share:         req.Share,
		ShareType:     req.Sharetype,
		FileName:      req.FileName,
		UserAgentHash: common.Md5String(string(c.GetHeader("User-Agent"))),
	}

	p := req.ParentDir
	if !strings.HasSuffix(p, "/") {
		p = p + "/"
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	uploadArg.FileParam, err = models.CreateFileParam(owner, p)
	if err != nil {
		klog.Errorf("file param error: %v, owner: %s", err, owner)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("file param error: %v", err)})
		return
	}

	var handlerParam = &base.HandlerParam{
		Ctx:   ctx,
		Owner: uploadArg.FileParam.Owner,
	}
	var fileHandler = drivers.Adaptor.NewFileHandler(uploadArg.FileParam.FileType, handlerParam)
	if fileHandler == nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("handler not found, type: %s", uploadArg.FileParam.FileType)})
		return
	}
	respBytes, err := fileHandler.UploadedBytes(uploadArg)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(upload.UploadedBytesResp)
	if err = json.Unmarshal(respBytes, &resp); err != nil {
		klog.Errorf("Failed to unmarshal response body: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
		return
	}
	c.JSON(consts.StatusOK, resp)
}

// UploadChunksMethod .
// @router /upload/upload-link/:uid [POST]
func UploadChunksMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var req upload.UploadChunksReq

	err = c.BindAndValidate(&req)
	if err != nil {
		klog.Errorf("bind and validate error: %v", err)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}
	req.RetJson = 1

	var uploadArg = &models.FileUploadArgs{
		FileParam:      &models.FileParam{},
		Node:           c.Param("node"),
		UploadId:       c.Param("uid"),
		UserAgentHash:  common.Md5String(string(c.GetHeader("User-Agent"))),
		RequestContext: c,
	}

	uploadArg.ChunkInfo = new(models.ResumableInfo)
	err = json.Unmarshal(common.ToBytes(req), &uploadArg.ChunkInfo)
	if err != nil {
		klog.Errorf("Parse to upload arg error: %v", err)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "parse to upload arg error"})
		return
	}

	header, err := c.FormFile("file")
	if err != nil {
		klog.Errorf("uploadID:%s, Failed to parse file: %v\n", uploadArg.UploadId, err)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "param invalid"})
		return
	}

	uploadArg.ChunkInfo.Share = req.Share
	uploadArg.ChunkInfo.ShareType = req.Sharetype
	uploadArg.ChunkInfo.Shareby = req.Shareby
	uploadArg.ChunkInfo.SharebyPath = req.SharebyPath
	uploadArg.ChunkInfo.File = header

	if req.Share == "1" {
		uploadArg.ChunkInfo.ParentDir = req.SharebyPath
	}

	p := uploadArg.ChunkInfo.ParentDir
	if p == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "path invalid"})
		return
	}

	uploadArg.Ranges = string(c.GetHeader("Content-Range"))
	if !strings.HasSuffix(p, "/") {
		p = p + "/"
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	uploadArg.FileParam, err = models.CreateFileParam(owner, p)
	if err != nil {
		klog.Errorf("file param error: %v, owner: %s", err, owner)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("file param error: %v", err)})
		return
	}

	var handlerParam = &base.HandlerParam{
		Ctx:   ctx,
		Owner: uploadArg.FileParam.Owner,
	}
	var fileHandler = drivers.Adaptor.NewFileHandler(uploadArg.FileParam.FileType, handlerParam)
	if fileHandler == nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("handler not found, type: %s", uploadArg.FileParam.FileType)})
		return
	}
	respBytes, err := fileHandler.UploadChunks(uploadArg)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(upload.UploadChunksResp)
	klog.Infof("req.ResumableChunksNumber=%d, req.ResumableTotalChunks=%d", req.ResumableChunkNumber, req.ResumableTotalChunks)
	if req.ResumableChunkNumber == req.ResumableTotalChunks {
		resp.Success = nil
		resp.Items = make([]*upload.UploadChunksFileItem, 0)
		if err = json.Unmarshal(respBytes, &resp.Items); err != nil {
			klog.Errorf("Failed to unmarshal response body: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
			return
		}
	} else {
		resp.Items = nil
		resp.Success = new(upload.UploadChunksSuccess)
		if err = json.Unmarshal(respBytes, &resp.Success); err != nil {
			klog.Errorf("Failed to unmarshal response body: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
			return
		}
	}
	c.JSON(consts.StatusOK, Coalesce(resp.Success, resp.Items))
}

func Coalesce(vals ...interface{}) interface{} {
	for _, v := range vals {
		if val := reflect.ValueOf(v); !isNil(val) {
			if val.Kind() != reflect.Ptr && val.Kind() != reflect.Interface {
				return v
			}
			if !val.IsNil() {
				return v
			}
		}
	}
	return nil
}

func isNil(val reflect.Value) bool {
	switch val.Kind() {
	case reflect.Ptr, reflect.Interface, reflect.Map, reflect.Slice, reflect.Chan, reflect.Func:
		return val.IsNil()
	default:
		return false
	}
}

// SyncUploadChunksMethod .
// @router /seafhttp/:upload/:uid [POST]
func SyncUploadChunksMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var requestPath = string(c.Request.RequestURI())
	var uploadReq upload.UploadChunksReq

	err = c.BindAndValidate(&uploadReq)
	if err != nil {
		klog.Errorf("Sync uploadChunks, bind and validate error: %v", err)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	uploadPath := uploadReq.ParentDir
	if !strings.HasSuffix(uploadPath, "/") {
		uploadPath = uploadPath + "/"
	}

	var uploadType = c.Param("upload")
	var uid = c.Param("uid")
	var url = fmt.Sprintf("http://seafile:8082/%s/%s?ret-json=1", uploadType, uid)

	klog.Infof("Sync uploadChunks, path: %s, owner: %s, uploadPath: %s, url: %s", requestPath, owner, uploadPath, url)

	var br io.Reader
	var req, _ = http.NewRequest(http.MethodPost, url, br)

	c.Request.Header.VisitAll(func(key, value []byte) {
		req.Header.Set(string(key), string(value))
	})
	req.Header.Set(common.REQUEST_HEADER_OWNER, owner)

	body := c.Request.Body()
	req.Body = io.NopCloser(bytes.NewReader(body))
	req.ContentLength = int64(len(body))

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		klog.Errorf("Sync uploadChunks, redirect error: %v", err)
		c.String(http.StatusBadRequest, err.Error())
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		c.String(resp.StatusCode, "upload files failed")
		return
	}

	for k, vv := range resp.Header {
		for _, v := range vv {
			c.Header(k, v)
		}
	}

	bodyRes, err := io.ReadAll(resp.Body)
	if err != nil {
		klog.Errorf("Sync uploadChunks, read resp error: %v", err)
		c.String(http.StatusBadRequest, err.Error())
		return
	}

	result := new(upload.UploadChunksResp)
	if uploadReq.ResumableChunkNumber == uploadReq.ResumableTotalChunks {
		result.Success = nil
		result.Items = make([]*upload.UploadChunksFileItem, 0)
		if err = json.Unmarshal(bodyRes, &result.Items); err != nil {
			klog.Errorf("Sync uploadChunks, failed to unmarshal response body: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
			return
		}
	} else {
		result.Items = nil
		result.Success = new(upload.UploadChunksSuccess)
		if err = json.Unmarshal(bodyRes, &result.Success); err != nil {
			klog.Errorf("Sync uploadChunks, failed to unmarshal response body: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
			return
		}
	}

	c.JSON(consts.StatusOK, Coalesce(result.Success, result.Items))
}
