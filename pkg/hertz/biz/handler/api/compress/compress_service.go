// Code generated by hertz generator.

package compress

import (
	"context"
	"files/pkg/common"
	compressUtils "files/pkg/compress"
	"files/pkg/drivers"
	"files/pkg/drivers/base"
	"files/pkg/files"
	compress "files/pkg/hertz/biz/model/api/compress"
	"files/pkg/models"
	"files/pkg/tasks"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"k8s.io/klog/v2"
	"os"
	"path/filepath"
	"strings"
)

// CompressMethod .
// @router /api/compress/ [POST]
func CompressMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var req compress.CompressReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	fileType := ""
	// 计算总文件大小
	var totalSize int64
	var parsedReqPaths []string
	var fileList []string // 存储所有待压缩文件的绝对路径
	for _, path := range req.Paths {
		// 转换为绝对路径
		fileParam, err := models.CreateFileParam(owner, path)
		if err != nil {
			klog.Errorf("Invalid path: %s", path)
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
			return
		}

		if fileParam.FileType != "drive" && fileParam.FileType != "cache" {
			klog.Errorf("file type not support: %s", fileParam.FileType)
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "file type not support"})
			return
		}

		if fileType == "" {
			fileType = fileParam.FileType
		}

		if fileParam.FileType != fileType {
			klog.Error("file type not consistent")
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "file type not consistent"})
			return
		}

		uri, err := fileParam.GetResourceUri()
		if err != nil {
			klog.Errorf("Invalid path: %s", path)
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
			return
		}
		absPath := filepath.Join(uri, fileParam.Path)
		parsedReqPaths = append(parsedReqPaths, absPath)

		// 递归收集文件
		fileList = append(fileList, compressUtils.CollectFiles(absPath)...)
	}

	totalSize = 0
	for _, filePath := range fileList {
		info, err := os.Stat(filePath)
		if os.IsNotExist(err) {
			klog.Errorf("Path not found: %s", filePath)
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
			return
		}
		if err != nil {
			klog.Errorf("Error accessing path: %s", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
		totalSize += info.Size()
	}

	outURLPath := strings.TrimPrefix(string(c.Path()), "/api/compress/")
	if outURLPath == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "Output path not specified"})
		return
	}

	fileParam, err := models.CreateFileParam(owner, outURLPath)
	if err != nil {
		klog.Errorf("Invalid path: %s", outURLPath)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}
	// no need to check if is drive or cache here
	if fileParam.FileType != fileType {
		klog.Error("file type not consistent")
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "file type not consistent"})
		return
	}
	uri, err := fileParam.GetResourceUri()
	if err != nil {
		klog.Errorf("Invalid path: %s", outURLPath)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}
	outURLPath = filepath.Join(uri, fileParam.Path)
	outPath := tasks.AddVersionSuffix(outURLPath, fileParam, strings.HasSuffix(outURLPath, "/"), "")
	outPath = filepath.Join(uri, fileParam.Path)

	outDir := filepath.Dir(outPath)
	err = files.MkdirAllWithChown(nil, outDir, 0755)
	if err != nil {
		klog.Errorf("Failed to create output directory: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	klog.Infof("Created output directory: %s for outPath: %s", outDir, outPath)

	commonParentDir := compressUtils.CalculateCommonParentDir(parsedReqPaths)
	relPathList := compressUtils.GenerateRelativePaths(commonParentDir, fileList)

	compressParam := &models.CompressParam{
		Owner:       owner,
		Action:      "compress",
		Format:      req.Format,
		FileList:    fileList,
		RelPathList: relPathList,
		SrcPath:     "",
		DstPath:     outPath,
		TotalSize:   totalSize,
		Override:    false,
	}

	handler := drivers.Adaptor.NewFileHandler(fileType, &base.HandlerParam{})

	task, err := handler.Compress(compressParam)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{
			"code":    1,
			"message": err.Error(),
		})
		return
	}

	resp := new(compress.CompressResp)
	resp.TaskId = task.Id()
	c.JSON(consts.StatusOK, resp)
}

// UncompressMethod .
// @router /api/uncompress/*path [POST]
func UncompressMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var req compress.UncompressReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	klog.Infof("Uncopress Req: %+v", req)

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	// 获取压缩文件路径
	compressFilePath := strings.TrimPrefix(string(c.Path()), "/api/uncompress/")
	if compressFilePath == "" {
		klog.Errorf("No file path provided")
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "no file path provided"})
		return
	}

	fileParam, err := models.CreateFileParam(owner, compressFilePath)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	compressUri, err := fileParam.GetResourceUri()
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}
	compressFilePath, err = filepath.Abs(filepath.Join(compressUri, fileParam.Path))
	if err != nil {
		klog.Errorf("Invalid compress path")
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}
	compressFullFileName := filepath.Base(compressFilePath)
	compressFileName := ""
	for {
		ext := filepath.Ext(compressFullFileName)
		if len(ext) == 0 {
			break
		}
		compressFileName = compressFullFileName[:len(compressFullFileName)-len(ext)]
		compressFullFileName = compressFileName
	}

	// fileType
	fileType := fileParam.FileType
	if fileType != "drive" && fileType != "cache" {
		klog.Errorf("file type not support: %s", fileParam.FileType)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "file type not support"})
		return
	}

	// 验证目标目录
	fileParam, err = models.CreateFileParam(owner, filepath.Join(req.Destination, compressFileName)+"/")
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	if fileParam.FileType != fileType {
		klog.Error("file type not consistent")
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "file type not consistent"})
		return
	}

	destUri, err := fileParam.GetResourceUri()
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}
	dest, err := filepath.Abs(filepath.Join(destUri, fileParam.Path))
	if err != nil {
		klog.Errorf("Invalid destination path")
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	if !req.Override {
		klog.Infof("Before add version suffix: %s", dest)
		tasks.AddVersionSuffix(dest, fileParam, strings.HasSuffix(dest, "/"), "")
		dest = filepath.Join(destUri, fileParam.Path)
		klog.Infof("After add version suffix: %s", dest)
	}

	klog.Infof("Now begin to uncompress procedure!")

	uncompressParam := &models.CompressParam{
		Owner:       owner,
		Action:      "uncompress",
		Format:      "",
		FileList:    []string{},
		RelPathList: []string{},
		SrcPath:     compressFilePath,
		DstPath:     dest,
		TotalSize:   0,
		Override:    req.Override,
	}

	handler := drivers.Adaptor.NewFileHandler(fileType, &base.HandlerParam{})

	task, err := handler.Uncompress(uncompressParam)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{
			"code":    1,
			"message": err.Error(),
		})
		return
	}

	resp := new(compress.UncompressResp)
	resp.TaskId = task.Id()
	c.JSON(consts.StatusOK, resp)
}
