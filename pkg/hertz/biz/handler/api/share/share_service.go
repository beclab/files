// Code generated by hertz generator.

package share

import (
	"context"
	"encoding/json"
	"files/pkg/common"
	"files/pkg/drivers/sync/seahub"
	"files/pkg/files"
	"files/pkg/hertz/biz/dal/database"
	"files/pkg/models"
	"fmt"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/google/uuid"
	"gorm.io/gorm"
	"k8s.io/klog/v2"
	"net/url"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	share "files/pkg/hertz/biz/model/api/share"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

const (
	PERMISSION_NONE = iota
	PERMISSION_VIEW
	PERMISSION_UPLOAD
	PERMISSION_EDIT
	PERMISSION_ADMIN
)

// CreateSharePath .
// @router /share/share_path/*path [POST]
func CreateSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.CreateSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	p := "/" + c.Param("path")
	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}
	fileParam, err := models.CreateFileParam(owner, p)
	if err != nil {
		klog.Errorf("file param error: %v, owner: %s", err, owner)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("file param error: %v", err)})
		return
	}
	if fileParam.FileType != "drive" && fileParam.FileType != "sync" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "file type not supported"})
		return
	}

	if req.ShareType != "internal" && req.ShareType != "external" && req.ShareType != "smb" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "share type not supported"})
		return
	}

	if fileParam.FileType == "sync" && req.ShareType != "internal" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "share type not supported for file type sync"})
		return
	}

	expireIn, expireTime := AdjustExpire(req.ExpireIn, req.ExpireTime)

	now := time.Now().UTC().Format(time.RFC3339Nano)

	sharePath := &share.SharePath{
		Owner:       owner,
		FileType:    fileParam.FileType,
		Extend:      fileParam.Extend,
		Path:        fileParam.Path,
		ShareType:   req.ShareType,
		Name:        req.Name,
		PasswordMd5: common.Md5String(req.Password),
		ExpireIn:    expireIn,
		ExpireTime:  expireTime,
		Permission:  req.Permission,
		CreateTime:  now,
		UpdateTime:  now,
	}
	res, err := database.CreateSharePath([]*share.SharePath{sharePath}, database.DB)
	if err != nil {
		klog.Errorf("postgres.CreateSharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.CreateSharePathResp)
	resp.SharePath = new(share.ViewSharePath)
	if err = json.Unmarshal(common.ToBytes(res[0]), &resp.SharePath); err != nil {
		klog.Errorf("Failed to unmarshal response body: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
		return
	}
	resp.SharePath.SharedByMe = true
	c.JSON(consts.StatusOK, resp)
}

// ListSharePath .
// @router /share/share_path/:node/ [GET]
func ListSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_paths.id", "=", &queryParams.AND, false)
	database.BuildStringQueryParam(req.Owner, "share_paths.owner", "=", &queryParams.AND, false)
	database.BuildStringQueryParam(req.FileType, "share_paths.file_type", "=", &queryParams.AND, false)
	database.BuildStringQueryParam(req.Extend, "share_paths.extend", "=", &queryParams.AND, false)
	database.BuildStringQueryParam(req.Path, "share_paths.path", "=", &queryParams.AND, false)
	database.BuildStringQueryParam(req.ShareType, "share_paths.share_type", "=", &queryParams.AND, false)
	database.BuildStringQueryParam(req.Name, "share_paths.name", "=", &queryParams.AND, false)

	if req.ExpireIn != 0 {
		currentTime := time.Now()
		expireTime := currentTime.Add(time.Duration(req.ExpireIn) * time.Millisecond).Format(time.RFC3339)
		database.BuildStringQueryParam(expireTime, "share_paths.expire_time", "<=", &queryParams.AND, true)
	}

	joinConditions := []*database.JoinCondition{}
	if req.SharedToMe {
		joinConditions = append(joinConditions, &database.JoinCondition{
			Table:     "share_paths",
			Field:     "id",
			JoinTable: "share_members",
			JoinField: "path_id",
		})
		database.BuildStringQueryParam(owner, "share_members.share_member", "=", &queryParams.AND, true)
	}
	if req.SharedByMe {
		database.BuildStringQueryParam(owner, "share_paths.owner", "=", &queryParams.AND, true)
	}

	res, total, err := database.QuerySharePath(queryParams, 0, 0, "", "", joinConditions)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	klog.Infof("~~~Debug log: QuerySharePath total: %d", total)
	klog.Infof("~~~Debug log: QuerySharePath result: %+v", res)

	resp := new(share.ListSharePathResp)
	resp.Total = int32(total)
	resp.SharePaths = []*share.ViewSharePath{}
	for _, sharePath := range res {
		viewPath := new(share.ViewSharePath)
		if err = json.Unmarshal(common.ToBytes(sharePath), &viewPath); err != nil {
			klog.Errorf("Failed to unmarshal response body: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
			return
		}
		if sharePath.Owner == owner {
			viewPath.SharedByMe = true
		}
		resp.SharePaths = append(resp.SharePaths, viewPath)
	}
	c.JSON(consts.StatusOK, resp)
}

// DeleteSharePath .
// @router /share/share_path/:node/ [DELETE]
func DeleteSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.DeleteSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	tx := database.DB.Begin()
	err = DeleteSharePathRelations(req.PathId, tx)
	if err != nil {
		klog.Errorf("DeleteSharePath error: %v", err)
		tx.Rollback()
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	err = database.DeleteSharePath(req.PathId, tx)
	if err != nil {
		tx.Rollback()
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	err = tx.Commit().Error
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.DeleteSharePathResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

// GenerateShareToken .
// @router /api/share/share_token/:node/ [POST]
func GenerateShareToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.GenerateShareTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_paths.id", "=", &queryParams.AND, true)
	_, total, err := database.QuerySharePath(queryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	if total == 0 {
		klog.Errorf("No SharePath found for pathId: %s", req.PathId)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath not found"})
		return
	}

	shareToken := &share.ShareToken{
		PathID:   req.PathId,
		Token:    uuid.New().String(),
		ExpireAt: ParseTime(req.ExpireAt),
	}
	res, err := database.CreateShareToken([]*share.ShareToken{shareToken}, database.DB)
	if err != nil {
		klog.Errorf("postgres.CreateSharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.GenerateShareTokenResp)
	resp.ShareToken = res[0]
	c.JSON(consts.StatusOK, resp)
}

// ListShareToken .
// @router /api/share/share_token/:node/ [GET]
func ListShareToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListShareTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_tokens.path_id", "=", &queryParams.AND, true)

	res, total, err := database.QueryShareToken(queryParams, 0, 0, "share_tokens.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareToken error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	klog.Infof("~~~Debug log: QueryShareToken total: %d", total)
	klog.Infof("~~~Debug log: QueryShareToken result: %+v", res)

	resp := new(share.ListShareTokenResp)
	resp.Total = int32(total)
	resp.ShareTokens = res
	c.JSON(consts.StatusOK, resp)
}

// RevokeShareToken .
// @router /api/share/share_token/:node/ [DELETE]
func RevokeShareToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.RevokeShareTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	err = database.DeleteShareToken(req.Token, database.DB)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.RevokeShareTokenResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

// AddShareMember .
// @router /share/share_member/:node/ [POST]
func AddShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.AddShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_paths.id", "=", &queryParams.AND, true)
	sharePaths, total, err := database.QuerySharePath(queryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	if total == 0 {
		klog.Errorf("No SharePath found for pathId: %s", req.PathId)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath not found"})
		return
	}

	sharePath := sharePaths[0]
	klog.Infof("SharePath: %+v", sharePath)
	if req.Permission > sharePath.Permission {
		klog.Errorf("ShareMember permission %d is over SharePath permission %d", req.Permission, sharePath.Permission)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath permission over SharePath"})
		return
	}

	now := time.Now().UTC().Format(time.RFC3339Nano)

	tx := database.DB.Begin()

	// all shareMembers with a same permission in one request for now
	shareTos := strings.Split(req.ShareMember, ",")
	var shareMembers []*share.ShareMember
	for _, shareTo := range shareTos {
		shareMember := &share.ShareMember{
			PathID:      req.PathId,
			ShareMember: shareTo,
			Permission:  req.Permission,
			CreateTime:  now,
			UpdateTime:  now,
		}
		shareMembers = append(shareMembers, shareMember)
	}

	res, err := database.CreateShareMember(shareMembers, tx)
	if err != nil {
		klog.Errorf("postgres.CreateShareMember error: %v", err)
		tx.Rollback()
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	if sharePath.FileType == "sync" {
		seaResp, err := seahub.HandlePutDirSharedItems(sharePath, shareMembers, "user")
		if err != nil {
			klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
			for _, shareMember := range shareMembers {
				subErr := database.DeleteShareMember(shareMember.ID, tx) // rollback
				if subErr != nil {
					klog.Errorf("postgres.DeleteShareMember error: %v", subErr)
				}
			}
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
		klog.Infof("postgres.HandlePutDirSharedItems response: %+v", seaResp)
	}

	err = tx.Commit().Error
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.AddShareMemberResp)
	resp.ShareMember = res[0]
	c.JSON(consts.StatusOK, resp)
}

// ListShareMember .
// @router /share/share_member/:node/ [GET]
func ListShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	if req.Permission != "" {
		permissions := strings.Split(req.Permission, ",")
		for _, permission := range permissions {
			p, err := strconv.Atoi(permission)
			if p < PERMISSION_NONE || p > PERMISSION_ADMIN || err != nil {
				c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "Permission out of range"})
				return
			}
		}
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_members.path_id", "=", &queryParams.AND, false)
	database.BuildStringQueryParam(req.ShareMember, "share_members.share_member", "=", &queryParams.AND, false)
	database.BuildIntQueryParam(req.Permission, "share_members.permission", "=", &queryParams.AND, false)

	res, total, err := database.QueryShareMember(queryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	klog.Infof("~~~Debug log: QueryShareMember total: %d", total)
	klog.Infof("~~~Debug log: QueryShareMember result: %+v", res)

	resp := new(share.ListShareMemberResp)
	resp.Total = int32(total)
	resp.ShareMembers = res
	c.JSON(consts.StatusOK, resp)
}

// UpdateShareMemberPermission .
// @router /share/share_member/:node/ [PUT]
func UpdateShareMemberPermission(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.UpdateShareMemberPermissionReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildIntQueryParam(req.MemberId, "share_members.id", "=", &queryParams.AND, true)
	memberRes, memberTotal, err := database.QueryShareMember(queryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil || memberTotal == 0 {
		klog.Errorf("QueryShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	shareMember := memberRes[0]

	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(shareMember.PathID, "share_paths.id", "=", &queryParams.AND, true)
	pathRes, pathTotal, err := database.QuerySharePath(queryParams, 0, 0, "share_paths.id", "ASC", nil)
	if err != nil || pathTotal == 0 {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	sharePath := pathRes[0]

	tx := database.DB.Begin()

	oldPermission := shareMember.Permission
	if sharePath.FileType == "sync" {
		shareMember.Permission = req.Permission
		seaResp, err := seahub.HandlePostDirSharedItems(sharePath, shareMember, "user")
		if err != nil {
			klog.Errorf("postgres.HandlePostDirSharedItems error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
		klog.Infof("postgres.HandlePostDirSharedItems response: %+v", seaResp)
	}

	err = database.UpdateShareMember(req.MemberId, map[string]interface{}{"permission": req.Permission}, tx)
	if err != nil {
		if sharePath.FileType == "sync" {
			shareMember.Permission = oldPermission
			_, subErr := seahub.HandlePostDirSharedItems(sharePath, shareMember, "user") // rollback
			if subErr != nil {
				klog.Errorf("postgres.HandlePostDirSharedItems error: %v", subErr)
			}
		}
		tx.Rollback()
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	err = tx.Commit().Error
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.UpdateShareMemberPermissionResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

// RemoveShareMember .
// @router /share/share_member/:node/ [DELETE]
func RemoveShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.RemoveShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildIntQueryParam(int(req.MemberId), "share_members.id", "=", &queryParams.AND, true)
	memberRes, memberTotal, err := database.QueryShareMember(queryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil || memberTotal == 0 {
		klog.Errorf("QueryShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	shareMember := memberRes[0]

	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(shareMember.PathID, "share_paths.id", "=", &queryParams.AND, true)
	pathRes, pathTotal, err := database.QuerySharePath(queryParams, 0, 0, "share_paths.id", "ASC", nil)
	if err != nil || pathTotal == 0 {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	sharePath := pathRes[0]

	tx := database.DB.Begin()

	if sharePath.FileType == "sync" {
		seaResp, err := seahub.HandleDeleteDirSharedItems(sharePath, shareMember, "user")
		if err != nil {
			klog.Errorf("postgres.HandleDeleteDirSharedItems error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
		klog.Infof("postgres.HandleDeleteDirSharedItems response: %+v", seaResp)
	}

	err = database.DeleteShareMember(req.MemberId, tx)
	if err != nil {
		if sharePath.FileType == "sync" {
			_, subErr := seahub.HandlePutDirSharedItems(sharePath, []*share.ShareMember{shareMember}, "user") // rollback
			if subErr != nil {
				klog.Errorf("postgres.HandleDeleteDirSharedItems error: %v", subErr)
			}
		}
		tx.Rollback()
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	err = tx.Commit().Error
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.RemoveShareMemberResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

func ParseTime(t string) string {
	var expireTimeMillis int64
	if _, err := strconv.ParseInt(t, 10, 64); err == nil {
		val, _ := strconv.ParseInt(t, 10, 64)
		expireTimeMillis = val
	} else {
		parsedTime, err := time.Parse(time.RFC3339, t)
		if err != nil {
			return ""
		}
		expireTimeMillis = parsedTime.UnixMilli()
	}
	return time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
}

func AdjustExpire(expireIn int64, expireTime string) (int64, string) {
	currentTime := time.Now()
	currentTimeMillis := currentTime.UnixMilli()

	if expireTime == "" {
		if expireIn == 0 {
			return 0, ""
		}
		return expireIn, currentTime.Add(time.Duration(expireIn) * time.Millisecond).Format(time.RFC3339)
	}

	var expireTimeMillis int64
	if _, err := strconv.ParseInt(expireTime, 10, 64); err == nil {
		val, _ := strconv.ParseInt(expireTime, 10, 64)
		expireTimeMillis = val
	} else {
		parsedTime, err := time.Parse(time.RFC3339, expireTime)
		if err != nil {
			return 0, ""
		}
		expireTimeMillis = parsedTime.UnixMilli()
	}

	if expireIn != 0 {
		calculatedExpireTimeMillis := currentTimeMillis + expireIn
		if calculatedExpireTimeMillis > expireTimeMillis {
			return expireIn, currentTime.Add(time.Duration(expireIn) * time.Millisecond).Format(time.RFC3339)
		}
		return expireTimeMillis - currentTimeMillis, time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
	}

	remaining := expireTimeMillis - currentTimeMillis
	if remaining < 0 {
		return 0, time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
	}
	return remaining, time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
}

func DeleteSharePathRelations(pathId string, tx *gorm.DB) error {
	commit := false
	if tx == nil {
		tx = database.DB.Begin()
		commit = true
	}
	pathQueryParams := &database.QueryParams{}
	pathQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(pathId, "share_paths.id", "=", &pathQueryParams.AND, true)
	pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		tx.Rollback()
		return err
	}
	klog.Infof("pathTotal: %d", pathTotal)
	deletePath := pathRes[0]

	tokenQueryParams := &database.QueryParams{}
	tokenQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(pathId, "share_tokens.path_id", "=", &tokenQueryParams.AND, true)
	tokenRes, tokenTotal, err := database.QueryShareToken(tokenQueryParams, 0, 0, "share_tokens.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareToken error: %v", err)
		tx.Rollback()
		return err
	}
	klog.Infof("tokenTotal: %d", tokenTotal)
	for _, shareToken := range tokenRes {
		err = database.DeleteShareToken(shareToken.Token, tx)
		if err != nil {
			klog.Errorf("DeleteShareToken error: %v", err)
			tx.Rollback()
			return err
		}
	}

	memberQueryParams := &database.QueryParams{}
	memberQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(pathId, "share_members.path_id", "=", &memberQueryParams.AND, true)
	memberRes, memberTotal, err := database.QueryShareMember(memberQueryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QueryShareMember error: %v", err)
		tx.Rollback()
		return err
	}
	klog.Infof("memberTotal: %d", memberTotal)

	if deletePath.FileType == "sync" {
		for _, shareMember := range memberRes {
			seaResp, err := seahub.HandleDeleteDirSharedItems(deletePath, shareMember, "user")
			if err != nil {
				klog.Errorf("postgres.HandleDeleteDirSharedItems error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("postgres.HandleDeleteDirSharedItems response: %+v", seaResp)
		}
	}

	for _, shareMember := range memberRes {
		err = database.DeleteShareMember(shareMember.ID, tx)
		if err != nil {
			klog.Errorf("DeleteShareMember error: %v", err)
			tx.Rollback()
			return err
		}
	}

	for _, sharePath := range pathRes {
		err = database.DeleteSharePath(sharePath.ID, tx)
		if err != nil {
			klog.Errorf("DeleteSharePath error: %v", err)
			tx.Rollback()
			return err
		}
	}

	if commit {
		return tx.Commit().Error
	}
	return nil
}

func RenameRelativeAdjustShare(fileParam *models.FileParam, dstPath string, parsePath bool, tx *gorm.DB) error {
	commit := false
	if tx == nil {
		tx = database.DB.Begin()
		commit = true
	}
	if strings.HasSuffix(fileParam.Path, "/") &&
		(fileParam.FileType == "drive" || fileParam.FileType == "sync") {
		var err error

		srcPath := fileParam.Path
		if parsePath {
			var srcName, _ = files.GetFileNameFromPath(fileParam.Path)
			srcName, err = url.PathUnescape(srcName)
			if err != nil {
				klog.Errorf("PathUnescape error: %v", err)
				tx.Rollback()
				return err
			}
			dstName, err := url.PathUnescape(dstPath)
			if err != nil {
				klog.Errorf("PathUnescape error: %v", err)
				tx.Rollback()
				return err
			}
			dstPath = strings.TrimSuffix(fileParam.Path, srcName+"/") + dstName + "/"
		}

		if srcPath != dstPath {
			pathQueryParams := &database.QueryParams{}
			pathQueryParams.AND = []database.Filter{}
			database.BuildStringQueryParam(fileParam.Owner, "share_paths.owner", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(fileParam.FileType, "share_paths.file_type", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(fileParam.Extend, "share_paths.extend", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(fileParam.Path+"%", "share_paths.path", "LIKE", &pathQueryParams.AND, true)
			pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "LENGTH(share_paths.path)", "DESC NULLS LAST", nil)
			if err != nil {
				klog.Errorf("QuerySharePath error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("pathTotal: %d", pathTotal)

			for _, sharePath := range pathRes {
				updatePath := dstPath + strings.TrimPrefix(sharePath.Path, fileParam.Path)
				err = database.UpdateSharePath(sharePath.ID, map[string]interface{}{
					"path": updatePath,
				}, tx)
				if err != nil {
					klog.Errorf("UpdateSharePath error: %v", err)
					tx.Rollback()
					return err
				}
			}
		}
	}
	if commit {
		return tx.Commit().Error
	}
	return nil
}

func DeleteRelativeAdjustShare(fileParam *models.FileParam, dirents []string, tx *gorm.DB) error {
	commit := false
	if tx == nil {
		tx = database.DB.Begin()
		commit = true
	}
	if fileParam.FileType == "drive" || fileParam.FileType == "sync" {
		var unsharePaths []string
		for _, dirent := range dirents {
			if strings.HasSuffix(dirent, "/") {
				unsharePaths = append(unsharePaths, dirent)
			}
		}
		if len(unsharePaths) > 0 {
			pathQueryParams := &database.QueryParams{}
			pathQueryParams.AND = []database.Filter{}
			database.BuildStringQueryParam(fileParam.Owner, "share_paths.owner", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(fileParam.FileType, "share_paths.file_type", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(fileParam.Extend, "share_paths.extend", "=", &pathQueryParams.AND, true)
			pathQueryParams.OR = []database.Filter{}
			for _, dirent := range unsharePaths {
				database.BuildStringQueryParam(dirent+"%", "share_paths.path", "LIKE", &pathQueryParams.OR, true)
			}
			pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "LENGTH(share_paths.path)", "DESC NULLS LAST", nil)
			if err != nil {
				klog.Errorf("QuerySharePath error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("pathTotal: %d", pathTotal)

			var internalSharePaths []*share.SharePath
			var externalSharePaths []*share.SharePath
			for _, sharePath := range pathRes {
				if sharePath.ShareType == "internal" {
					internalSharePaths = append(internalSharePaths, sharePath)
				} else if sharePath.ShareType == "external" {
					externalSharePaths = append(externalSharePaths, sharePath)
				}
			}

			tokenQueryParams := &database.QueryParams{}
			tokenQueryParams.OR = []database.Filter{}
			for _, sharePath := range externalSharePaths {
				database.BuildStringQueryParam(sharePath.ID, "share_tokens.path_id", "=", &tokenQueryParams.OR, true)
			}
			tokenRes, tokenTotal, err := database.QueryShareToken(tokenQueryParams, 0, 0, "share_tokens.id", "ASC", nil)
			if err != nil {
				klog.Errorf("QueryShareToken error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("tokenTotal: %d", tokenTotal)
			for _, shareToken := range tokenRes {
				err = database.DeleteShareToken(shareToken.Token, tx)
				if err != nil {
					klog.Errorf("DeleteShareToken error: %v", err)
					tx.Rollback()
					continue
				}
			}

			memberQueryParams := &database.QueryParams{}
			memberQueryParams.OR = []database.Filter{}
			for _, sharePath := range internalSharePaths {
				database.BuildStringQueryParam(sharePath.ID, "share_members.path_id", "=", &memberQueryParams.OR, true)
			}
			memberRes, memberTotal, err := database.QueryShareMember(memberQueryParams, 0, 0, "", "", nil)
			if err != nil {
				klog.Errorf("QueryShareMember error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("memberTotal: %d", memberTotal)

			for _, shareMember := range memberRes {
				err = database.DeleteShareMember(shareMember.ID, tx)
				if err != nil {
					klog.Errorf("DeleteShareMember error: %v", err)
					tx.Rollback()
					return err
				}
			}

			for _, sharePath := range pathRes {
				err = database.DeleteSharePath(sharePath.ID, tx)
				if err != nil {
					klog.Errorf("DeleteSharePath error: %v", err)
					tx.Rollback()
					return err
				}
			}
		}
	}
	if commit {
		return tx.Commit().Error
	}
	return nil
}

func MoveRelativeAdjustShare(action string, src, dst *models.FileParam, tx *gorm.DB) error {
	commit := false
	if tx == nil {
		tx = database.DB.Begin()
		commit = true
	}
	var err error
	if action == "move" && strings.HasSuffix(src.Path, "/") {
		if src.FileType == "drive" {
			if dst.FileType == "drive" {
				// just update share info, very like rename
				err = RenameRelativeAdjustShare(src, dst.Path, false, tx)
				if err != nil {
					klog.Errorf("MoveRelativeAdjustShare drive-drive error: %v", err)
					tx.Rollback()
					return err
				}
			} else if dst.FileType == "sync" {
				// when internal, create sync share; else remove share info
				pathQueryParams := &database.QueryParams{}
				pathQueryParams.AND = []database.Filter{}
				database.BuildStringQueryParam(src.Owner, "share_paths.owner", "=", &pathQueryParams.AND, true)
				database.BuildStringQueryParam(src.FileType, "share_paths.file_type", "=", &pathQueryParams.AND, true)
				database.BuildStringQueryParam(src.Extend, "share_paths.extend", "=", &pathQueryParams.AND, true)
				database.BuildStringQueryParam(src.Path+"%", "share_paths.path", "LIKE", &pathQueryParams.AND, true)
				pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "LENGTH(share_paths.path)", "DESC NULLS LAST", nil)
				if err != nil {
					klog.Errorf("QuerySharePath error: %v", err)
					tx.Rollback()
					return err
				}
				klog.Infof("pathTotal: %d", pathTotal)

				var internalSharePaths []*share.SharePath // will be updated, and create sync share
				var externalSharePaths []*share.SharePath // will be removed with token removed either
				var smbSharePaths []*share.SharePath      // will be removed
				for _, sharePath := range pathRes {
					if sharePath.ShareType == "internal" {
						internalSharePaths = append(internalSharePaths, sharePath)
					} else if sharePath.ShareType == "external" {
						externalSharePaths = append(externalSharePaths, sharePath)
					} else if sharePath.ShareType == "smb" {
						smbSharePaths = append(smbSharePaths, sharePath)
					}
				}

				// internal
				memberQueryParams := &database.QueryParams{}
				memberQueryParams.OR = []database.Filter{}
				for _, sharePath := range internalSharePaths {
					database.BuildStringQueryParam(sharePath.ID, "share_members.path_id", "=", &memberQueryParams.OR, true)
				}
				memberRes, memberTotal, err := database.QueryShareMember(memberQueryParams, 0, 0, "", "", nil)
				if err != nil {
					klog.Errorf("QueryShareMember error: %v", err)
					tx.Rollback()
					return err
				}
				klog.Infof("memberTotal: %d", memberTotal)

				for _, sharePath := range pathRes {
					err = database.UpdateSharePath(sharePath.ID, map[string]interface{}{
						"file_type": dst.FileType,
						"extend":    dst.Extend,
						"path":      dst.Path + strings.TrimPrefix(sharePath.Path, src.Path),
					}, tx)
					if err != nil {
						klog.Errorf("UpdateSharePath error: %v", err)
						tx.Rollback()
						return err
					}
					sharePath.FileType = dst.FileType
					sharePath.Extend = dst.Extend
					sharePath.Path = dst.Path + strings.TrimPrefix(sharePath.Path, src.Path)

					shareMembers := []*share.ShareMember{}
					for _, shareMember := range memberRes {
						if shareMember.PathID == sharePath.ID {
							shareMembers = append(shareMembers, shareMember)
						}
					}
					seaResp, err := seahub.HandlePutDirSharedItems(sharePath, shareMembers, "user")
					if err != nil {
						klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
						tx.Rollback()
						return err
					}
					klog.Infof("postgres.HandlePutDirSharedItems response: %+v", seaResp)
				}

				// external
				tokenQueryParams := &database.QueryParams{}
				tokenQueryParams.OR = []database.Filter{}
				for _, sharePath := range externalSharePaths {
					database.BuildStringQueryParam(sharePath.ID, "share_tokens.path_id", "=", &tokenQueryParams.OR, true)
				}
				tokenRes, tokenTotal, err := database.QueryShareToken(tokenQueryParams, 0, 0, "share_tokens.id", "ASC", nil)
				if err != nil {
					klog.Errorf("QueryShareToken error: %v", err)
					tx.Rollback()
					return err
				}
				klog.Infof("tokenTotal: %d", tokenTotal)
				for _, shareToken := range tokenRes {
					err = database.DeleteShareToken(shareToken.Token, tx)
					if err != nil {
						klog.Errorf("DeleteShareToken error: %v", err)
						tx.Rollback()
						return err
					}
				}

				for _, sharePath := range externalSharePaths {
					err = database.DeleteSharePath(sharePath.ID, tx)
					if err != nil {
						klog.Errorf("DeleteSharePath error: %v", err)
						tx.Rollback()
						return err
					}
				}

				// smb
				for _, sharePath := range smbSharePaths {
					err = database.DeleteSharePath(sharePath.ID, tx)
					if err != nil {
						klog.Errorf("DeleteSharePath error: %v", err)
						tx.Rollback()
						return err
					}
				}
			} else {
				// remove share info, very like delete
				// drive relative only operate database, it can be done after real delete
				dir, dirent := filepath.Split(strings.TrimSuffix(src.Path, "/"))
				if !strings.HasSuffix(dir, "/") {
					dir += "/"
				}
				deleteFileParam := &models.FileParam{
					Owner:    src.Owner,
					FileType: src.FileType,
					Extend:   src.Extend,
					Path:     dir,
				}
				dirents := []string{dirent + "/"}
				err = DeleteRelativeAdjustShare(deleteFileParam, dirents, tx)
				if err != nil {
					klog.Errorf("MoveRelativeAdjustShare drive-other error: %v", err)
					tx.Rollback()
					return err
				}
			}
		} else if src.FileType == "sync" {
			pathQueryParams := &database.QueryParams{}
			pathQueryParams.AND = []database.Filter{}
			database.BuildStringQueryParam(src.Owner, "share_paths.owner", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(src.FileType, "share_paths.file_type", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(src.Extend, "share_paths.extend", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(src.Path+"%", "share_paths.path", "LIKE", &pathQueryParams.AND, true)
			pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "LENGTH(share_paths.path)", "DESC NULLS LAST", nil)
			if err != nil {
				klog.Errorf("QuerySharePath error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("pathTotal: %d", pathTotal)

			memberQueryParams := &database.QueryParams{}
			memberQueryParams.OR = []database.Filter{}
			for _, sharePath := range pathRes {
				database.BuildStringQueryParam(sharePath.ID, "share_members.path_id", "=", &memberQueryParams.OR, true)
			}
			memberRes, memberTotal, err := database.QueryShareMember(memberQueryParams, 0, 0, "", "", nil)
			if err != nil {
				klog.Errorf("QueryShareMember error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("memberTotal: %d", memberTotal)

			if dst.FileType == "drive" {
				// remove sync share, and update share info
				for _, sharePath := range pathRes {
					err = database.UpdateSharePath(sharePath.ID, map[string]interface{}{
						"file_type": dst.FileType,
						"extend":    dst.Extend,
						"path":      dst.Path + strings.TrimPrefix(sharePath.Path, src.Path),
					}, tx)
					if err != nil {
						klog.Errorf("UpdateSharePath error: %v", err)
						tx.Rollback()
						return err
					}
				}
			} else if dst.FileType == "sync" {
				// update sync share (same repo don't need) and share info
				for _, sharePath := range pathRes {
					err = database.UpdateSharePath(sharePath.ID, map[string]interface{}{
						"file_type": dst.FileType,
						"extend":    dst.Extend,
						"path":      dst.Path + strings.TrimPrefix(sharePath.Path, src.Path),
					}, tx)
					if err != nil {
						klog.Errorf("UpdateSharePath error: %v", err)
						tx.Rollback()
						return err
					}
					if src.Extend != dst.Extend {
						sharePath.Extend = dst.Extend
						sharePath.Path = dst.Path + strings.TrimPrefix(sharePath.Path, src.Path)
						// diff repo, need to remove sync share and create sync share (sync share update only support permission update)
						for _, shareMember := range memberRes {
							if shareMember.PathID == sharePath.ID {
								// seafile auto unshare, no need to delete, just put a new share
								seaResp, err := seahub.HandlePutDirSharedItems(sharePath, []*share.ShareMember{shareMember}, "user")
								if err != nil {
									klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
									tx.Rollback()
									return err
								}
								klog.Infof("postgres.HandlePutDirSharedItems response: %+v", seaResp)
							}
						}
					}
				}
			} else {
				// remove share info
				for _, sharePath := range pathRes {
					err = DeleteSharePathRelations(sharePath.ID, tx)
					if err != nil {
						klog.Errorf("DeleteSharePathRelations error: %v", err)
						tx.Rollback()
						return err
					}
					err = database.DeleteSharePath(sharePath.ID, tx)
					if err != nil {
						klog.Errorf("deleteSharePath error: %v", err)
						tx.Rollback()
						return err
					}
				}
			}
		}
	}
	if commit {
		return tx.Commit().Error
	}
	return nil
}
