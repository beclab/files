// Code generated by hertz generator.

package share

import (
	"context"
	"encoding/json"
	"files/pkg/common"
	"files/pkg/hertz/biz/dal/postgres"
	"files/pkg/models"
	"fmt"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/google/uuid"
	"k8s.io/klog/v2"
	"strconv"
	"strings"
	"time"

	share "files/pkg/hertz/biz/model/api/share"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

const (
	PERMISSION_NONE = iota
	PERMISSION_VIEW
	PERMISSION_UPLOAD
	PERMISSION_EDIT
	PERMISSION_ADMIN
)

// CreateSharePath .
// @router /share/share_path/*path [POST]
func CreateSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.CreateSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	p := "/" + c.Param("path")
	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}
	fileParam, err := models.CreateFileParam(owner, p)
	if err != nil {
		klog.Errorf("file param error: %v, owner: %s", err, owner)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("file param error: %v", err)})
		return
	}
	if fileParam.FileType != "drive" && fileParam.FileType != "sync" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "file type not supported"})
		return
	}

	expireIn, expireTime := AdjustExpire(req.ExpireIn, req.ExpireTime)

	now := time.Now().UTC().Format(time.RFC3339Nano)

	sharePath := &share.SharePath{
		Owner:       owner,
		FileType:    fileParam.FileType,
		Extend:      common.Md5String(fmt.Sprintf("%s%d", p, time.Now().UnixNano())),
		Path:        p,
		ShareType:   req.ShareType,
		Name:        req.Name,
		PasswordMd5: common.Md5String(req.Password),
		ExpireIn:    expireIn,
		ExpireTime:  expireTime,
		Permission:  req.Permission,
		CreateTime:  now,
		UpdateTime:  now,
	}
	res, err := postgres.CreateSharePath([]*share.SharePath{sharePath})
	if err != nil {
		klog.Errorf("postgres.CreateSharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.CreateSharePathResp)
	resp.SharePath = new(share.ViewSharePath)
	if err = json.Unmarshal(common.ToBytes(res[0]), &resp.SharePath); err != nil {
		klog.Errorf("Failed to unmarshal response body: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
		return
	}
	resp.SharePath.SharedByMe = true
	c.JSON(consts.StatusOK, resp)
}

// ListSharePath .
// @router /share/share_path/:node/ [GET]
func ListSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	queryParams := &postgres.QueryParams{}
	queryParams.AND = []postgres.Filter{}
	postgres.BuildStringQueryParam(req.PathId, "share_paths.id", "=", &queryParams.AND, false)
	postgres.BuildStringQueryParam(req.Owner, "share_paths.owner", "=", &queryParams.AND, false)
	postgres.BuildStringQueryParam(req.FileType, "share_paths.file_type", "=", &queryParams.AND, false)
	postgres.BuildStringQueryParam(req.Extend, "share_paths.extend", "=", &queryParams.AND, false)
	postgres.BuildStringQueryParam(req.Path, "share_paths.path", "=", &queryParams.AND, false)
	postgres.BuildStringQueryParam(req.ShareType, "share_paths.share_type", "=", &queryParams.AND, false)
	postgres.BuildStringQueryParam(req.Name, "share_paths.name", "=", &queryParams.AND, false)

	if req.ExpireIn != 0 {
		currentTime := time.Now()
		expireTime := currentTime.Add(time.Duration(req.ExpireIn) * time.Millisecond).Format(time.RFC3339)
		postgres.BuildStringQueryParam(expireTime, "share_paths.expire_time", "<=", &queryParams.AND, true)
	}

	joinConditions := []*postgres.JoinCondition{}
	if req.SharedToMe {
		joinConditions = append(joinConditions, &postgres.JoinCondition{
			Table:     "share_paths",
			Field:     "share_paths.id",
			JoinTable: "share_members",
			JoinField: "share_members.share_id",
		})
		postgres.BuildStringQueryParam(owner, "share_members.share_member", "=", &queryParams.AND, true)
	}
	if req.SharedByMe {
		postgres.BuildStringQueryParam(owner, "share_paths.owner", "=", &queryParams.AND, true)
	}

	res, total, err := postgres.QuerySharePath(queryParams, 0, 0, "", "", joinConditions)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	klog.Infof("~~~Debug log: QuerySharePath total: %d", total)
	klog.Infof("~~~Debug log: QuerySharePath result: %+v", res)

	resp := new(share.ListSharePathResp)
	resp.Total = int32(total)
	resp.SharePaths = []*share.ViewSharePath{}
	for _, sharePath := range res {
		viewPath := new(share.ViewSharePath)
		if err = json.Unmarshal(common.ToBytes(sharePath), &viewPath); err != nil {
			klog.Errorf("Failed to unmarshal response body: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
			return
		}
		if sharePath.Owner == owner {
			viewPath.SharedByMe = true
		}
		resp.SharePaths = append(resp.SharePaths, viewPath)
	}
	c.JSON(consts.StatusOK, resp)
}

// DeleteSharePath .
// @router /share/share_path/:node/ [DELETE]
func DeleteSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.DeleteSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	err = postgres.DeleteSharePath(req.PathId)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.DeleteSharePathResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

// GenerateShareToken .
// @router /api/share/share_token/:node/ [POST]
func GenerateShareToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.GenerateShareTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	queryParams := &postgres.QueryParams{}
	queryParams.AND = []postgres.Filter{}
	postgres.BuildStringQueryParam(req.PathId, "share_paths.id", "=", &queryParams.AND, true)
	_, total, err := postgres.QuerySharePath(queryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	if total == 0 {
		klog.Errorf("No SharePath found for pathId: %s", req.PathId)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath not found"})
		return
	}

	shareToken := &share.ShareToken{
		PathID:   req.PathId,
		Token:    uuid.New().String(),
		ExpireAt: ParseTime(req.ExpireAt),
	}
	res, err := postgres.CreateShareToken([]*share.ShareToken{shareToken})
	if err != nil {
		klog.Errorf("postgres.CreateSharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.GenerateShareTokenResp)
	resp.ShareToken = res[0]
	c.JSON(consts.StatusOK, resp)
}

// ListShareToken .
// @router /api/share/share_token/:node/ [GET]
func ListShareToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListShareTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	queryParams := &postgres.QueryParams{}
	queryParams.AND = []postgres.Filter{}
	postgres.BuildStringQueryParam(req.PathId, "share_tokens.path_id", "=", &queryParams.AND, true)

	res, total, err := postgres.QueryShareToken(queryParams, 0, 0, "share_tokens.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareToken error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	klog.Infof("~~~Debug log: QueryShareToken total: %d", total)
	klog.Infof("~~~Debug log: QueryShareToken result: %+v", res)

	resp := new(share.ListShareTokenResp)
	resp.Total = int32(total)
	resp.ShareTokens = res
	c.JSON(consts.StatusOK, resp)
}

// RevokeShareToken .
// @router /api/share/share_token/:node/ [DELETE]
func RevokeShareToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.RevokeShareTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	err = postgres.DeleteShareToken(req.Token)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.RevokeShareTokenResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

// AddShareMember .
// @router /share/share_member/:node/ [POST]
func AddShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.AddShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	queryParams := &postgres.QueryParams{}
	queryParams.AND = []postgres.Filter{}
	postgres.BuildStringQueryParam(req.PathId, "share_paths.id", "=", &queryParams.AND, true)
	_, total, err := postgres.QuerySharePath(queryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	if total == 0 {
		klog.Errorf("No SharePath found for pathId: %s", req.PathId)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath not found"})
		return
	}

	now := time.Now().UTC().Format(time.RFC3339Nano)

	shareMember := &share.ShareMember{
		PathID:      req.PathId,
		ShareMember: req.ShareMember,
		Permission:  req.Permission,
		CreateTime:  now,
		UpdateTime:  now,
	}
	res, err := postgres.CreateShareMember([]*share.ShareMember{shareMember})
	if err != nil {
		klog.Errorf("postgres.CreateShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.AddShareMemberResp)
	resp.ShareMember = res[0]
	c.JSON(consts.StatusOK, resp)
}

// ListShareMember .
// @router /share/share_member/:node/ [GET]
func ListShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	if req.Permission != "" {
		permissions := strings.Split(req.Permission, ",")
		for _, permission := range permissions {
			p, err := strconv.Atoi(permission)
			if p < PERMISSION_NONE || p > PERMISSION_ADMIN || err != nil {
				c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "Permission out of range"})
				return
			}
		}
	}

	queryParams := &postgres.QueryParams{}
	queryParams.AND = []postgres.Filter{}
	postgres.BuildStringQueryParam(req.PathId, "share_members.path_id", "=", &queryParams.AND, false)
	postgres.BuildStringQueryParam(req.ShareMember, "share_members.share_member", "=", &queryParams.AND, false)
	postgres.BuildIntQueryParam(req.Permission, "share_members.permission", "=", &queryParams.AND, false)

	res, total, err := postgres.QueryShareMember(queryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	klog.Infof("~~~Debug log: QueryShareMember total: %d", total)
	klog.Infof("~~~Debug log: QueryShareMember result: %+v", res)

	resp := new(share.ListShareMemberResp)
	resp.Total = int32(total)
	resp.ShareMembers = res
	c.JSON(consts.StatusOK, resp)
}

// UpdateShareMemberPermission .
// @router /share/share_member/:node/ [PUT]
func UpdateShareMemberPermission(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.UpdateShareMemberPermissionReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	err = postgres.UpdateShareMemberFields(req.MemberId, map[string]interface{}{"permission": req.Permission})
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.UpdateShareMemberPermissionResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

// RemoveShareMember .
// @router /share/share_member/:node/ [DELETE]
func RemoveShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.RemoveShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	err = postgres.DeleteShareMember(req.MemberId)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.RemoveShareMemberResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

func ParseTime(t string) string {
	var expireTimeMillis int64
	if _, err := strconv.ParseInt(t, 10, 64); err == nil {
		val, _ := strconv.ParseInt(t, 10, 64)
		expireTimeMillis = val
	} else {
		parsedTime, err := time.Parse(time.RFC3339, t)
		if err != nil {
			return ""
		}
		expireTimeMillis = parsedTime.UnixMilli()
	}
	return time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
}

func AdjustExpire(expireIn int64, expireTime string) (int64, string) {
	currentTime := time.Now()
	currentTimeMillis := currentTime.UnixMilli()

	if expireTime == "" {
		if expireIn == 0 {
			return 0, ""
		}
		return expireIn, currentTime.Add(time.Duration(expireIn) * time.Millisecond).Format(time.RFC3339)
	}

	var expireTimeMillis int64
	if _, err := strconv.ParseInt(expireTime, 10, 64); err == nil {
		val, _ := strconv.ParseInt(expireTime, 10, 64)
		expireTimeMillis = val
	} else {
		parsedTime, err := time.Parse(time.RFC3339, expireTime)
		if err != nil {
			return 0, ""
		}
		expireTimeMillis = parsedTime.UnixMilli()
	}

	if expireIn != 0 {
		calculatedExpireTimeMillis := currentTimeMillis + expireIn
		if calculatedExpireTimeMillis > expireTimeMillis {
			return expireIn, currentTime.Add(time.Duration(expireIn) * time.Millisecond).Format(time.RFC3339)
		}
		return expireTimeMillis - currentTimeMillis, time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
	}

	remaining := expireTimeMillis - currentTimeMillis
	if remaining < 0 {
		return 0, time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
	}
	return remaining, time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
}
