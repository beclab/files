// Code generated by hertz generator.

package share

import (
	"context"
	"encoding/json"
	"files/pkg/client"
	"files/pkg/common"
	"files/pkg/drivers/sync/seahub"
	"files/pkg/drivers/sync/seahub/seaserv"
	"files/pkg/files"
	"files/pkg/hertz/biz/dal/database"
	"files/pkg/hertz/biz/handler"
	"files/pkg/models"
	"files/pkg/samba"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/google/uuid"
	"gorm.io/gorm"
	"k8s.io/klog/v2"

	share "files/pkg/hertz/biz/model/api/share"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

const (
	PERMISSION_NONE = iota
	PERMISSION_VIEW
	PERMISSION_UPLOAD
	PERMISSION_EDIT
	PERMISSION_ADMIN
)

// CreateSharePath .
// @router /share/share_path/*path [POST]
func CreateSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.CreateSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}
	klog.Infof("req.UploadSizeLimit=%d", req.UploadSizeLimit)

	p := "/" + c.Param("path")
	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	p = strings.TrimSpace(p)

	klog.Infof("[samba] CreateSharePath, owner: %s, data: %s, path: %s", owner, common.ParseString(req), p)

	fileParam, err := models.CreateFileParam(owner, p)
	if err != nil {
		klog.Errorf("[samba] CreateSharePath, file param error: %v, owner: %s", err, owner)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("file param error: %v", err)})
		return
	}
	if req.Name == "" {
		req.Name = filepath.Base(strings.TrimSuffix(fileParam.Path, "/"))
		if req.Name == "" {
			req.Name = "root"
		}
	}

	if fileParam.FileType != common.Drive && fileParam.FileType != common.Sync {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "file type not supported"})
		return
	}

	if fileParam.FileType == common.Sync && req.ShareType != common.Internal {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "share type not supported for file type sync"})
		return
	}

	if req.ShareType == common.ShareTypeSMB { // ~ create samba
		createSambaShare(c, owner, &req, fileParam)
		return
	}

	permission := int32(PERMISSION_ADMIN)
	// share_type detail check
	if req.ShareType == common.ShareTypeExternal {
		if req.Password == "" {
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "external share must have a password"})
			return
		}
		if req.Permission == 0 {
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "external share must have a permission"})
			return
		}
		if req.ExpireIn == 0 && req.ExpireTime == "" {
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "expire time must not be empty"})
			return
		}
		permission = req.Permission
	} else if req.ShareType == common.ShareTypeInternal || req.ShareType == common.ShareTypeSMB {
		// internal forced use default ADMIN as permission, no matter req.Permission of what value
		queryParams := &database.QueryParams{}
		queryParams.AND = []database.Filter{}
		database.BuildStringQueryParam(fileParam.Owner, "share_paths.owner", "=", &queryParams.AND, true)
		database.BuildStringQueryParam(fileParam.FileType, "share_paths.file_type", "=", &queryParams.AND, true)
		database.BuildStringQueryParam(fileParam.Extend, "share_paths.extend", "=", &queryParams.AND, true)
		database.BuildStringQueryParam(fileParam.Path, "share_paths.path", "=", &queryParams.AND, true)
		database.BuildStringQueryParam(req.ShareType, "share_paths.share_type", "=", &queryParams.AND, true)
		_, total, err := database.QuerySharePath(queryParams, 0, 0, "", "", nil)
		if err != nil {
			klog.Errorf("QuerySharePath error: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
		if total > 0 {
			handler.RespError(c, common.ErrorMessageInternalPathExists)
			return
		}
	}

	expireIn, expireTime := common.AdjustExpire(req.ExpireIn, req.ExpireTime)

	now := time.Now().UTC().Format(time.RFC3339Nano)

	password := common.Md5String(req.Password)
	if req.ShareType == common.ShareTypeExternal {
		if err := client.CreateShareRole(owner); err != nil {
			klog.Errorf("create external share cluster role error: %v, user: %s", err, owner)
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "create external share failed"})
			return
		}
	}

	tx := database.DB.Begin()

	sharePath := &share.SharePath{
		Owner:           owner,
		FileType:        fileParam.FileType,
		Extend:          fileParam.Extend,
		Path:            fileParam.Path,
		ShareType:       req.ShareType,
		Name:            req.Name,
		PasswordMd5:     password,
		UploadSizeLimit: req.UploadSizeLimit,
		ExpireIn:        expireIn,
		ExpireTime:      expireTime,
		Permission:      permission,
		CreateTime:      now,
		UpdateTime:      now,
		SyncVirtualID:   "",
	}
	res, err := database.CreateSharePath([]*share.SharePath{sharePath}, tx)
	if err != nil {
		tx.Rollback()
		klog.Errorf("postgres.CreateSharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	var addShareMembers = []*share.ShareMember{}
	for _, shareMemberInfo := range req.ShareMembers {
		if shareMemberInfo.ShareMember != owner { // owner can't be added or updated
			shareMember := &share.ShareMember{
				PathID:      res[0].ID,
				ShareMember: shareMemberInfo.ShareMember,
				Permission:  shareMemberInfo.Permission,
				CreateTime:  now,
				UpdateTime:  now,
			}
			addShareMembers = append(addShareMembers, shareMember)
		}
	}

	syncVirtualId := sharePath.SyncVirtualID
	// add member
	var addRes = []*share.ShareMember{}
	if len(addShareMembers) > 0 {
		addRes, err = database.CreateShareMember(addShareMembers, tx)
		if err != nil {
			klog.Errorf("postgres.CreateShareMember error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}

		if sharePath.FileType == common.Sync {
			seaResp, err := seahub.HandlePutDirSharedItems(sharePath, addShareMembers, "user")
			if err != nil {
				klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
				tx.Rollback()
				c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
				return
			}
			klog.Infof("postgres.HandlePutDirSharedItems response: %+v", seaResp)

			var seaRespJson map[string]interface{}
			err = json.Unmarshal([]byte(seaResp), &seaRespJson)
			if err != nil {
				klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
				tx.Rollback()
				c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
				return
			}
			klog.Infof("postgres.HandlePutDirSharedItems seaRespJson: %+v", seaRespJson)
			if success, ok := seaRespJson["success"].([]interface{}); ok && len(success) > 0 {
				if firstItem, ok := success[0].(map[string]interface{}); ok {
					if syncId, ok := firstItem["sync_virtual_id"].(string); ok && syncId != "" {
						syncVirtualId = syncId
					}
				}
			}

			if syncVirtualId == "" && sharePath.Path != "/" {
				virtualRepo, err := seaserv.GlobalSeafileAPI.GetVirtualRepo(sharePath.Extend, sharePath.Path, owner)
				if err != nil {
					klog.Errorf("GetVirtualRepo error: %v", err)
					tx.Rollback()
					c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
					return
				} else {
					klog.Infof("GetVirtualRepo response: %+v", virtualRepo)
					syncVirtualId = virtualRepo["repo_id"]
				}
			}

			if syncVirtualId != "" {
				err = database.UpdateSharePath(res[0].ID, map[string]interface{}{
					"sync_virtual_id": syncVirtualId,
				}, tx)
				if err != nil {
					klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
					tx.Rollback()
					c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
					return
				}
			}
		}
	}
	klog.Infof("add member response: %+v", addRes)

	err = tx.Commit().Error
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	var result = new(share.ViewSharePath)
	if err = json.Unmarshal(common.ToBytes(res[0]), &result); err != nil {
		klog.Errorf("Failed to unmarshal response body: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
		return
	}
	result.SharedByMe = true
	for _, shareMember := range addRes {
		resMember := &share.ViewSharePathMembers{
			ID:          shareMember.ID,
			ShareMember: shareMember.ShareMember,
			Permission:  shareMember.Permission,
		}
		result.ShareMembers = append(result.ShareMembers, resMember)
	}

	if result.FileType == common.Sync {
		repo, err := seaserv.GlobalSeafileAPI.GetRepo(result.Extend)
		if err != nil {
			klog.Errorf("GetRepo error: %v", err)
		} else {
			result.SyncRepoName = repo["repo_name"]
		}
	}

	if syncVirtualId != "" {
		result.SyncVirtualID = syncVirtualId
	}

	handler.RespSuccess(c, result)
}

// ListSharePath .
// @router /share/share_path/:node/ [GET]
func ListSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	if req.Permission != "" {
		permissions := strings.Split(req.Permission, ",")
		for _, permission := range permissions {
			p, err := strconv.Atoi(permission)
			if p < PERMISSION_NONE || p > PERMISSION_ADMIN || err != nil {
				c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "Permission out of range"})
				return
			}
		}
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	sharedToMe := true
	sharedByMe := true
	if req.SharedToMe != nil {
		klog.Infof("*req.SharedToMe=%t", *req.SharedToMe)
		sharedToMe = *req.SharedToMe
	}
	if req.SharedByMe != nil {
		klog.Infof("*req.SharedByMe=%t", *req.SharedByMe)
		sharedByMe = *req.SharedByMe
	}
	if !sharedToMe && !sharedByMe {
		c.JSON(consts.StatusOK, map[string]interface{}{
			"total":       0,
			"share_paths": []string{},
		})
		return
	} // no need to query any more
	klog.Infof("sharedToMe=%t, sharedByMe=%t", sharedToMe, sharedByMe)

	// sharedToMe
	sharedToMeRes := []*share.SharePath{}
	sharedToMeTotal := int64(0)

	if sharedToMe {
		sharedToMeQueryParams := &database.QueryParams{}
		sharedToMeQueryParams.AND = []database.Filter{}
		database.BuildStringQueryParam(req.PathId, "share_paths.id", "IN", &sharedToMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.FileType, "share_paths.file_type", "IN", &sharedToMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.Extend, "share_paths.extend", "IN", &sharedToMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.Path, "share_paths.path", "IN", &sharedToMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.ShareType, "share_paths.share_type", "IN", &sharedToMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.Name, "share_paths.name", "IN", &sharedToMeQueryParams.AND, true)

		if req.ExpireIn != 0 {
			currentTime := time.Now()
			expireTime := currentTime.Add(time.Duration(req.ExpireIn) * time.Millisecond).Format(time.RFC3339)
			database.BuildStringQueryParam(expireTime, "share_paths.expire_time", "<=", &sharedToMeQueryParams.AND, true)
		}

		sharedToMeJoinConditions := []*database.JoinCondition{}
		sharedToMeJoinConditions = append(sharedToMeJoinConditions, &database.JoinCondition{
			Table:     "share_paths",
			Field:     "id",
			JoinTable: "share_members",
			JoinField: "path_id",
		})
		database.BuildStringQueryParam(owner, "share_members.share_member", "=", &sharedToMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.Permission, "share_members.permission", "IN", &sharedToMeQueryParams.AND, true)
		if req.ShareRelativeUser != "" {
			database.BuildStringQueryParam(req.ShareRelativeUser, "share_paths.owner", "IN", &sharedToMeQueryParams.AND, true)
		}
		sharedToMeRes, sharedToMeTotal, err = database.QuerySharePath(sharedToMeQueryParams, 0, 0, "", "", sharedToMeJoinConditions)
		if err != nil {
			klog.Errorf("QuerySharePath error: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
	}

	//sharedByMe
	sharedByMeRes := []*share.SharePath{}
	sharedByMeTotal := int64(0)

	if sharedByMe {
		sharedByMeQueryParams := &database.QueryParams{}
		sharedByMeQueryParams.AND = []database.Filter{}
		database.BuildStringQueryParam(req.PathId, "share_paths.id", "IN", &sharedByMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.FileType, "share_paths.file_type", "IN", &sharedByMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.Extend, "share_paths.extend", "IN", &sharedByMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.Path, "share_paths.path", "IN", &sharedByMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.ShareType, "share_paths.share_type", "IN", &sharedByMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.Name, "share_paths.name", "IN", &sharedByMeQueryParams.AND, true)
		database.BuildStringQueryParam(req.Permission, "share_paths.permission", "IN", &sharedByMeQueryParams.AND, true)

		if req.ExpireIn != 0 {
			currentTime := time.Now()
			expireTime := currentTime.Add(time.Duration(req.ExpireIn) * time.Millisecond).Format(time.RFC3339)
			database.BuildStringQueryParam(expireTime, "share_paths.expire_time", "<=", &sharedByMeQueryParams.AND, true)
		}
		database.BuildStringQueryParam(owner, "share_paths.owner", "=", &sharedByMeQueryParams.AND, true)
		sharedByMeJoinConditions := []*database.JoinCondition{}
		if req.ShareRelativeUser != "" {
			sharedByMeJoinConditions = append(sharedByMeJoinConditions, &database.JoinCondition{
				Table:     "share_paths",
				Field:     "id",
				JoinTable: "share_members",
				JoinField: "path_id",
			})
			database.BuildStringQueryParam(req.ShareRelativeUser, "share_members.share_member", "IN", &sharedByMeQueryParams.AND, true)
		}
		sharedByMeRes, sharedByMeTotal, err = database.QuerySharePath(sharedByMeQueryParams, 0, 0, "", "", sharedByMeJoinConditions)
		if err != nil {
			klog.Errorf("QuerySharePath error: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
	}

	memberQueryParams := &database.QueryParams{}
	memberQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(owner, "share_members.share_member", "=", &memberQueryParams.AND, true)
	shareMembers, _, err := database.QueryShareMember(memberQueryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	for _, sharePath := range sharedByMeRes {
		if sharePath.ShareType != common.ShareTypeInternal || sharePath.Owner != owner {
			continue // always do not continue because of sharedToMeRes is always internal and owner not me, just for taking position
		}
		for _, shareMember := range shareMembers {
			if shareMember.PathID == sharePath.ID {
				sharePath.Permission = shareMember.Permission
			}
		}
	}

	for _, sharePath := range sharedToMeRes { // only shared with me possibly fit permission for member
		if sharePath.ShareType == common.ShareTypeInternal && sharePath.Owner != owner {
			for _, shareMember := range shareMembers {
				if shareMember.PathID == sharePath.ID {
					sharePath.Permission = shareMember.Permission
				}
			}
		}

	}

	res := append(sharedToMeRes, sharedByMeRes...)
	total := sharedToMeTotal + sharedByMeTotal

	var queryShareIds []string
	for _, r := range res {
		if r.ShareType == common.ShareTypeInternal || r.ShareType == common.ShareTypeSMB {
			queryShareIds = append(queryShareIds, r.ID)
		}
	}

	internalShareMembers, _ := database.QueryShareInternalMembers(queryShareIds)
	smbShareMembers, _ := database.QueryShareSmbMembers(queryShareIds)

	resp := new(share.ListSharePathResp)
	resp.Total = int32(total)
	resp.SharePaths = []*share.ViewSharePath{}
	for _, sharePath := range res {
		viewPath := new(share.ViewSharePath)
		if err = json.Unmarshal(common.ToBytes(sharePath), &viewPath); err != nil {
			klog.Errorf("Failed to unmarshal response body: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
			return
		}
		if sharePath.Owner == owner {
			viewPath.SharedByMe = true
		}

		if viewPath.FileType == common.Sync {
			repo, err := seaserv.GlobalSeafileAPI.GetRepo(viewPath.Extend)
			if err != nil {
				klog.Errorf("GetRepo error: %v", err)
			} else {
				viewPath.SyncRepoName = repo["repo_name"]
			}
		}

		if sharePath.ShareType == common.ShareTypeInternal {
			if len(internalShareMembers) > 0 {
				for _, u := range internalShareMembers {
					if u.PathID != viewPath.ID {
						continue
					}
					var user = &share.ViewSharePathUsers{
						ID:         fmt.Sprintf("%d", u.ID),
						Name:       u.ShareMember,
						Permission: u.Permission,
					}
					viewPath.Users = append(viewPath.Users, user)
				}
			}
		} else if sharePath.ShareType == common.ShareTypeSMB {
			viewPath.PublicSmb = sharePath.SmbSharePublic == 1
			viewPath.SmbLink = fmt.Sprintf("smb://%s/%s", os.Getenv("NODE_IP"), viewPath.Name)
			if len(smbShareMembers) > 0 {
				for _, u := range smbShareMembers {
					if u.PathId != viewPath.ID {
						continue
					}
					var user = &share.ViewSharePathUsers{
						ID:         u.UserId,
						Name:       u.UserName,
						Permission: u.Permission,
					}
					viewPath.Users = append(viewPath.Users, user)
				}
			}
		}

		resp.SharePaths = append(resp.SharePaths, viewPath)
	}
	c.JSON(consts.StatusOK, resp)
}

// UpdateSharePath .
// @router /api/share/share_path/ [PUT]
func UpdateSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.UpdateSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	err = database.UpdateSharePath(req.PathId, map[string]interface{}{"name": req.Name}, database.DB)
	if err != nil {
		klog.Errorf("postgres.UpdateShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_paths.id", "=", &queryParams.AND, true)
	res, total, err := database.QuerySharePath(queryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	if total == 0 {
		klog.Errorf("No SharePath found for pathId: %s", req.PathId)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath not found"})
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	resp := new(share.UpdateSharePathResp)
	resp.SharePath = new(share.ViewSharePath)
	if err = json.Unmarshal(common.ToBytes(res[0]), &resp.SharePath); err != nil {
		klog.Errorf("Failed to unmarshal response body: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
		return
	}
	resp.SharePath.SharedByMe = res[0].Owner == owner
	c.JSON(consts.StatusOK, resp)
}

// UpdateSharePathMembers .
// @router /api/share/share_path/share_members/ [PUT]
func UpdateSharePathMembers(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.UpdateSharePathMembersReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	pathId := req.PathId
	pathQueryParams := &database.QueryParams{}
	pathQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(pathId, "share_paths.id", "=", &pathQueryParams.AND, true)
	sharePaths, total, err := database.QuerySharePath(pathQueryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	if total == 0 {
		klog.Errorf("No SharePath found")
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath not found"})
		return
	}
	klog.Infof("share_paths: %v", sharePaths)
	sharePath := sharePaths[0]

	memberInfoMap := make(map[string]*share.AddOrUpdateShareMemberInfo)
	for _, memberInfo := range req.ShareMembers {
		if memberInfo.ShareMember != owner {
			memberInfoMap[memberInfo.ShareMember] = memberInfo
		}
	}

	memberQueryParams := &database.QueryParams{}
	memberQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(pathId, "share_members.path_id", "=", &memberQueryParams.AND, true)

	shareMembers, total, err := database.QueryShareMember(memberQueryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	memberMap := make(map[string]*share.ShareMember)
	for _, member := range shareMembers {
		memberMap[member.ShareMember] = member
	}

	var existedShareMembers = []*share.ShareMember{}
	var updateShareMembers = []*share.ShareMember{}
	var rollbackShareMembers = []*share.ShareMember{} // for rollback
	var addShareMembers = []*share.ShareMember{}
	var deleteShareMembers = []*share.ShareMember{}

	for _, member := range shareMembers {
		if _, exists := memberInfoMap[member.ShareMember]; exists {
		} else {
			deleteShareMembers = append(deleteShareMembers, member)
		}
	}

	now := time.Now().UTC().Format(time.RFC3339Nano)
	for _, shareMemberInfo := range memberInfoMap {
		if targetMember, exists := memberMap[shareMemberInfo.ShareMember]; exists {
			if targetMember.Permission != shareMemberInfo.Permission {
				updateShareMembers = append(updateShareMembers, &share.ShareMember{
					ID:          targetMember.ID,
					PathID:      pathId,
					ShareMember: targetMember.ShareMember,
					Permission:  shareMemberInfo.Permission,
					CreateTime:  now,
					UpdateTime:  now,
				})
				rollbackShareMembers = append(rollbackShareMembers, targetMember)
			} else {
				existedShareMembers = append(existedShareMembers, targetMember)
			}
		} else {
			addShareMembers = append(addShareMembers, &share.ShareMember{
				PathID:      pathId,
				ShareMember: shareMemberInfo.ShareMember,
				Permission:  shareMemberInfo.Permission,
				CreateTime:  now,
				UpdateTime:  now,
			})
		}
	}
	klog.Infof("existedShareMembers: %+v", existedShareMembers)
	klog.Infof("updateShareMembers: %+v", updateShareMembers)
	klog.Infof("rollbackShareMembers: %+v", rollbackShareMembers)
	klog.Infof("addShareMembers: %+v", addShareMembers)

	syncVirtualId := sharePath.SyncVirtualID

	tx := database.DB.Begin()

	// update
	for _, shareMember := range updateShareMembers {
		klog.Infof("updateShareMember: %+v", shareMember)
		err = database.UpdateShareMember(shareMember.ID, map[string]interface{}{"permission": shareMember.Permission}, tx)
		if err != nil {
			for _, rollbackShareMember := range rollbackShareMembers {
				if sharePath.FileType == common.Sync {
					_, subErr := seahub.HandlePostDirSharedItems(sharePath, rollbackShareMember, "user") // rollback
					if subErr != nil {
						klog.Errorf("postgres.HandlePostDirSharedItems error: %v", subErr)
					}
				}
			}
			klog.Errorf("postgres.UpdateShareMember error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}

		if sharePath.FileType == common.Sync {
			seaResp, err := seahub.HandlePostDirSharedItems(sharePath, shareMember, "user")
			if err != nil {
				klog.Errorf("postgres.HandlePostDirSharedItems error: %v", err)
				tx.Rollback()
				c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
				return
			}
			klog.Infof("postgres.HandlePostDirSharedItems response: %+v", seaResp)
		}
	}

	// delete
	for _, shareMember := range deleteShareMembers {
		if sharePath.FileType == common.Sync {
			seaResp, err := seahub.HandleDeleteDirSharedItems(sharePath, shareMember, "user")
			if err != nil {
				klog.Errorf("postgres.HandleDeleteDirSharedItems error: %v", err)
				tx.Rollback()
				c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
				return
			}
			klog.Infof("postgres.HandleDeleteDirSharedItems response: %+v", seaResp)
		}

		klog.Infof("deleteShareMember: %+v", shareMember)
		err = database.DeleteShareMember(shareMember.ID, tx)
		if err != nil {
			klog.Errorf("postgres.DeleteShareMember error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
	}

	// add
	var addRes = []*share.ShareMember{}
	if len(addShareMembers) > 0 {
		addRes, err = database.CreateShareMember(addShareMembers, tx)
		if err != nil {
			klog.Errorf("postgres.CreateShareMember error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}

		if sharePath.FileType == common.Sync {
			seaResp, err := seahub.HandlePutDirSharedItems(sharePath, addShareMembers, "user")
			if err != nil {
				klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
				tx.Rollback()
				c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
				return
			}
			klog.Infof("postgres.HandlePutDirSharedItems response: %+v", seaResp)

			var seaRespJson map[string]interface{}
			err = json.Unmarshal([]byte(seaResp), &seaRespJson)
			if err != nil {
				klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
				tx.Rollback()
				c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
				return
			}
			klog.Infof("postgres.HandlePutDirSharedItems seaRespJson: %+v", seaRespJson)

			if syncVirtualId == "" {
				if success, ok := seaRespJson["success"].([]interface{}); ok && len(success) > 0 {
					if firstItem, ok := success[0].(map[string]interface{}); ok {
						if syncId, ok := firstItem["sync_virtual_id"].(string); ok && syncId != "" {
							syncVirtualId = syncId
						}
					}
				}

				if syncVirtualId == "" && sharePath.Path != "/" {
					virtualRepo, err := seaserv.GlobalSeafileAPI.GetVirtualRepo(sharePath.Extend, sharePath.Path, owner)
					if err != nil {
						klog.Errorf("GetVirtualRepo error: %v", err)
						tx.Rollback()
						c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
						return
					} else {
						klog.Infof("GetVirtualRepo response: %+v", virtualRepo)
						syncVirtualId = virtualRepo["repo_id"]
					}
				}

				if syncVirtualId != "" {
					err = database.UpdateSharePath(sharePath.ID, map[string]interface{}{
						"sync_virtual_id": syncVirtualId,
					}, tx)
					if err != nil {
						klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
						tx.Rollback()
						c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
						return
					}
				}
			}
		}
	}
	klog.Infof("add member response: %+v", addRes)

	err = tx.Commit().Error
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.UpdateSharePathResp)

	var result = new(share.ViewSharePath)
	if err = json.Unmarshal(common.ToBytes(sharePath), &result); err != nil {
		klog.Errorf("Failed to unmarshal response body: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
		return
	}
	result.SharedByMe = true
	for _, shareMember := range existedShareMembers {
		resMember := &share.ViewSharePathMembers{
			ID:          shareMember.ID,
			ShareMember: shareMember.ShareMember,
			Permission:  shareMember.Permission,
		}
		result.ShareMembers = append(result.ShareMembers, resMember)
	}
	for _, shareMember := range updateShareMembers {
		resMember := &share.ViewSharePathMembers{
			ID:          shareMember.ID,
			ShareMember: shareMember.ShareMember,
			Permission:  shareMember.Permission,
		}
		result.ShareMembers = append(result.ShareMembers, resMember)
	}
	for _, shareMember := range addRes {
		resMember := &share.ViewSharePathMembers{
			ID:          shareMember.ID,
			ShareMember: shareMember.ShareMember,
			Permission:  shareMember.Permission,
		}
		result.ShareMembers = append(result.ShareMembers, resMember)
	}
	if result.FileType == common.Sync {
		repo, err := seaserv.GlobalSeafileAPI.GetRepo(result.Extend)
		if err != nil {
			klog.Errorf("GetRepo error: %v", err)
		} else {
			result.SyncRepoName = repo["repo_name"]
		}
	}

	if syncVirtualId != "" {
		// may be added newly
		result.SyncVirtualID = syncVirtualId
	}

	resp.SharePath = result

	handler.RespSuccess(c, resp)
}

// DeleteSharePath .
// @router /share/share_path/:node/ [DELETE]
func DeleteSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.DeleteSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	pathIds := strings.Split(req.PathIds, ",")

	klog.Infof("[samba] DeleteSharePath, owner: %s, pathIds: %v", owner, pathIds)

	deleteSmbSharePaths, err := database.QuerySmbShares(owner, common.ShareTypeSMB, pathIds, nil)

	failedPathIds := []string{}
	for _, pathId := range pathIds {
		// for every share path, it is a individual transaction
		tx := database.DB.Begin()
		err = DeleteSharePathRelations(pathId, tx)
		if err != nil {
			klog.Errorf("[samba] DeleteSharePath error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}

		err = database.DeleteSharePath(pathId, tx)
		if err != nil {
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}

		err = tx.Commit().Error
		if err != nil {
			klog.Errorf("[samba] DeleteSharePath error: %v", err)
			failedPathIds = append(failedPathIds, pathId)
		}
	}

	if len(failedPathIds) == len(pathIds) {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to delete all identified shared paths"})
		return
	}

	if len(failedPathIds) > 0 {
		c.AbortWithStatusJSON(consts.StatusOK, utils.H{"msg": "Part of identified shared paths delete failed: " + strings.Join(failedPathIds, ",")})
		return
	}

	if len(deleteSmbSharePaths) > 0 {
		// ~ delete samba share paths
		if err := database.DeleteSmbShareTx(owner, pathIds); err != nil {
			klog.Errorf("[samba] DeleteSharePath, delete samba failed, owner: %s, error: %v", owner, err)
			handler.RespError(c, fmt.Sprintf("Delete Smb Share Path Error: %v", err))
			return
		}

		var deleteSmbSharePathsFmt = samba.FormatSharePathViews(deleteSmbSharePaths)
		var smbs []*share.SmbCreate
		for _, item := range deleteSmbSharePathsFmt {
			if item.PublicShare {
				continue
			}
			var smbShareUser []string
			for _, u := range item.Members {
				smbShareUser = append(smbShareUser, u.UserName)
			}

			var smb = &share.SmbCreate{
				Owner: item.Owner,
				ID:    item.Id,
				Path:  fmt.Sprintf("/%s/%s%s", item.FileType, item.Extend, item.Path),
				User:  strings.Join(smbShareUser, ","),
			}
			smbs = append(smbs, smb)
		}

		if err := samba.SambaService.CreateShareSamba(smbs, "del"); err != nil {
			klog.Errorf("delete share path, create samba DELETE crd error: %v", err)
		}
	}

	resp := new(share.DeleteSharePathResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

// GenerateShareToken .
// @router /api/share/share_token/:node/ [POST]
func GenerateShareToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.GenerateShareTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_paths.id", "=", &queryParams.AND, true)
	_, total, err := database.QuerySharePath(queryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	if total == 0 {
		klog.Errorf("No SharePath found for pathId: %s", req.PathId)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath not found"})
		return
	}

	shareToken := &share.ShareToken{
		PathID:   req.PathId,
		Token:    uuid.New().String(),
		ExpireAt: ParseTime(req.ExpireAt),
	}
	res, err := database.CreateShareToken([]*share.ShareToken{shareToken}, database.DB)
	if err != nil {
		klog.Errorf("postgres.CreateSharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.GenerateShareTokenResp)
	resp.ShareToken = res[0]
	c.JSON(consts.StatusOK, resp)
}

// ListShareToken .
// @router /api/share/share_token/:node/ [GET]
func ListShareToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListShareTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_tokens.path_id", "=", &queryParams.AND, true)

	res, total, err := database.QueryShareToken(queryParams, 0, 0, "share_tokens.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareToken error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.ListShareTokenResp)
	resp.Total = int32(total)
	resp.ShareTokens = res
	c.JSON(consts.StatusOK, resp)
}

// RevokeShareToken .
// @router /api/share/share_token/:node/ [DELETE]
func RevokeShareToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.RevokeShareTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	err = database.DeleteShareToken(req.Token, database.DB)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.RevokeShareTokenResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

// AddShareMember .
// @router /share/share_member/:node/ [POST]
func AddShareMember(ctx context.Context, c *app.RequestContext) {
	// support internal and samba
	var err error
	var req share.AddShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_paths.id", "=", &queryParams.AND, true)
	sharePaths, total, err := database.QuerySharePath(queryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	if total == 0 {
		klog.Errorf("No SharePath found for pathId: %s", req.PathId)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath not found"})
		return
	}

	sharePath := sharePaths[0]
	klog.Infof("SharePath: %+v", sharePath)

	if sharePath.ShareType != common.ShareTypeInternal && sharePath.ShareType != common.ShareTypeSMB {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath is not internal"})
		return
	}

	for _, shareMemberInfo := range req.ShareMembers {
		if shareMemberInfo.ShareMember == sharePath.Owner {
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "Cannot share to yourself"})
			return
		}
		if shareMemberInfo.Permission == PERMISSION_NONE || shareMemberInfo.Permission == PERMISSION_UPLOAD {
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "ShareMember permission for internal is invalid"})
			return
		}
	}

	memberQueryParams := &database.QueryParams{}
	memberQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_members.path_id", "=", &memberQueryParams.AND, true)
	memberQueryParams.OR = []database.Filter{}
	for _, shareMemberInfo := range req.ShareMembers {
		database.BuildStringQueryParam(shareMemberInfo.ShareMember, "share_members.share_member", "=", &memberQueryParams.OR, true)
	}

	shareMembers, total, err := database.QueryShareMember(memberQueryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	memberMap := make(map[string]*share.ShareMember)
	for _, member := range shareMembers {
		memberMap[member.ShareMember] = member
	}

	now := time.Now().UTC().Format(time.RFC3339Nano)
	var addShareMembers = []*share.ShareMember{}
	var updateShareMembers = []*share.ShareMember{}
	var rollbackShareMembers = []*share.ShareMember{} // for rollback
	var existedShareMembers = []*share.ShareMember{}
	for _, shareMemberInfo := range req.ShareMembers {
		shareMember := &share.ShareMember{
			PathID:      req.PathId,
			ShareMember: shareMemberInfo.ShareMember,
			Permission:  shareMemberInfo.Permission,
			CreateTime:  now,
			UpdateTime:  now,
		}
		if targetMember, exists := memberMap[shareMember.ShareMember]; exists {
			shareMember.ID = targetMember.ID
			if targetMember.Permission != shareMemberInfo.Permission {
				updateShareMembers = append(updateShareMembers, shareMember)
				rollbackShareMembers = append(rollbackShareMembers, targetMember)
			} else {
				existedShareMembers = append(existedShareMembers, shareMember)
			}
		} else {
			addShareMembers = append(addShareMembers, shareMember)
		}
	}
	klog.Infof("addShareMembers: %+v", addShareMembers)
	klog.Infof("updateShareMembers: %+v", updateShareMembers)
	klog.Infof("rollbackShareMembers: %+v", rollbackShareMembers)
	klog.Infof("existedShareMembers: %+v", existedShareMembers)

	syncVirtualId := sharePath.SyncVirtualID

	tx := database.DB.Begin()

	// add
	var addRes = []*share.ShareMember{}
	if len(addShareMembers) > 0 {
		addRes, err = database.CreateShareMember(addShareMembers, tx)
		if err != nil {
			klog.Errorf("postgres.CreateShareMember error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}

		if sharePath.FileType == common.Sync {
			seaResp, err := seahub.HandlePutDirSharedItems(sharePath, addShareMembers, "user")
			if err != nil {
				klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
				tx.Rollback()
				c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
				return
			}
			klog.Infof("postgres.HandlePutDirSharedItems response: %+v", seaResp)

			if syncVirtualId == "" {
				var seaRespJson map[string]interface{}
				err = json.Unmarshal([]byte(seaResp), &seaRespJson)
				if err != nil {
					klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
					tx.Rollback()
					c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
					return
				}
				klog.Infof("postgres.HandlePutDirSharedItems seaRespJson: %+v", seaRespJson)
				if success, ok := seaRespJson["success"].([]interface{}); ok && len(success) > 0 {
					if firstItem, ok := success[0].(map[string]interface{}); ok {
						if syncId, ok := firstItem["sync_virtual_id"].(string); ok && syncId != "" {
							syncVirtualId = syncId
						}
					}
				}

				if syncVirtualId == "" && sharePath.Path != "/" {
					virtualRepo, err := seaserv.GlobalSeafileAPI.GetVirtualRepo(sharePath.Extend, sharePath.Path, owner)
					if err != nil {
						klog.Errorf("GetVirtualRepo error: %v", err)
						tx.Rollback()
						c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
						return
					} else {
						klog.Infof("GetVirtualRepo response: %+v", virtualRepo)
						syncVirtualId = virtualRepo["repo_id"]
					}
				}

				if syncVirtualId != "" {
					err = database.UpdateSharePath(sharePath.ID, map[string]interface{}{
						"sync_virtual_id": syncVirtualId,
					}, tx)
					if err != nil {
						klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
						tx.Rollback()
						c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
						return
					}
				}
			}
		}
	}

	// update
	for _, shareMember := range updateShareMembers {
		klog.Infof("updateShareMember: %+v", shareMember)
		err = database.UpdateShareMember(shareMember.ID, map[string]interface{}{"permission": shareMember.Permission}, tx)
		if err != nil {
			if sharePath.FileType == common.Sync {
				for _, rollbackShareMember := range rollbackShareMembers {
					_, subErr := seahub.HandlePostDirSharedItems(sharePath, rollbackShareMember, "user") // rollback
					if subErr != nil {
						klog.Errorf("postgres.HandlePostDirSharedItems error: %v", subErr)
					}
				}
			}
			klog.Errorf("postgres.UpdateShareMember error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}

		if sharePath.FileType == common.Sync {
			seaResp, err := seahub.HandlePostDirSharedItems(sharePath, shareMember, "user")
			if err != nil {
				klog.Errorf("postgres.HandlePostDirSharedItems error: %v", err)
				tx.Rollback()
				c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
				return
			}
			klog.Infof("postgres.HandlePostDirSharedItems response: %+v", seaResp)
		}
	}

	err = tx.Commit().Error
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.AddShareMemberResp)
	resp.Created = addRes
	resp.Updated = updateShareMembers
	resp.Existed = existedShareMembers
	c.JSON(consts.StatusOK, resp)
}

// ListShareMember .
// @router /share/share_member/:node/ [GET]
func ListShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	if req.Permission != "" {
		permissions := strings.Split(req.Permission, ",")
		for _, permission := range permissions {
			p, err := strconv.Atoi(permission)
			if p < PERMISSION_NONE || p > PERMISSION_ADMIN || err != nil {
				c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "Permission out of range"})
				return
			}
		}
	}

	queryParams := &database.QueryParams{}
	queryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(req.PathId, "share_members.path_id", "IN", &queryParams.AND, true)
	database.BuildStringQueryParam(req.ShareMember, "share_members.share_member", "IN", &queryParams.AND, true)
	database.BuildStringQueryParam(req.Permission, "share_members.permission", "IN", &queryParams.AND, true)

	res, total, err := database.QueryShareMember(queryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.ListShareMemberResp)
	resp.Total = int32(total)
	resp.ShareMembers = res
	c.JSON(consts.StatusOK, resp)
}

// UpdateShareMemberPermission .
// @router /share/share_member/:node/ [PUT]
func UpdateShareMemberPermission(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.UpdateShareMemberPermissionReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	memberInfoMap := make(map[int64]*share.UpdateShareMemberInfo)
	for _, memberInfo := range req.ShareMembers {
		memberInfoMap[memberInfo.MemberId] = memberInfo
	}

	queryParams := &database.QueryParams{}
	queryParams.OR = []database.Filter{}
	for _, shareMemberInfo := range req.ShareMembers {
		database.BuildIntQueryParam(int(shareMemberInfo.MemberId), "share_members.id", "=", &queryParams.OR, true)
	}

	shareMembers, total, err := database.QueryShareMember(queryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	memberMap := make(map[int64]*share.ShareMember)
	for _, member := range shareMembers {
		memberMap[member.ID] = member
	}

	pathQueryParams := &database.QueryParams{}
	pathQueryParams.OR = []database.Filter{}
	for _, shareMember := range shareMembers {
		database.BuildStringQueryParam(shareMember.PathID, "share_paths.id", "=", &pathQueryParams.OR, true)
	}
	sharePaths, total, err := database.QuerySharePath(pathQueryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	if total == 0 {
		klog.Errorf("No SharePath found")
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "SharePath not found"})
		return
	}

	var existedShareMembers = []*share.ShareMember{}
	var updateShareMembers = []*share.ShareMember{}
	var rollbackShareMembers = []*share.ShareMember{} // for rollback
	var notExistedShareMembers = []*share.UpdateShareMemberInfo{}
	var shareDeletedShareMembers = []*share.UpdateShareMemberInfo{}

	pathMap := make(map[int64]*share.SharePath)
	for _, member := range shareMembers {
		found := false
		for _, sharePath := range sharePaths {
			if member.PathID == sharePath.ID {
				pathMap[member.ID] = sharePath
				found = true
				break
			}
		}
		if !found {
			shareDeletedShareMembers = append(shareDeletedShareMembers, memberInfoMap[member.ID])
			delete(memberInfoMap, member.ID)
		}
	}

	now := time.Now().UTC().Format(time.RFC3339Nano)
	for _, shareMemberInfo := range memberInfoMap {
		if targetMember, exists := memberMap[shareMemberInfo.MemberId]; exists {
			if targetMember.Permission != shareMemberInfo.Permission {
				updateShareMembers = append(updateShareMembers, &share.ShareMember{
					ID:          targetMember.ID,
					PathID:      targetMember.PathID,
					ShareMember: targetMember.ShareMember,
					Permission:  shareMemberInfo.Permission,
					CreateTime:  now,
					UpdateTime:  now,
				})
				rollbackShareMembers = append(rollbackShareMembers, targetMember)
			} else {
				existedShareMembers = append(existedShareMembers, targetMember)
			}
		} else {
			notExistedShareMembers = append(notExistedShareMembers, shareMemberInfo)
		}
	}
	klog.Infof("existedShareMembers: %+v", existedShareMembers)
	klog.Infof("updateShareMembers: %+v", updateShareMembers)
	klog.Infof("rollbackShareMembers: %+v", rollbackShareMembers)
	klog.Infof("existedShareMembers: %+v", existedShareMembers)

	tx := database.DB.Begin()

	// update
	for _, shareMember := range updateShareMembers {
		klog.Infof("updateShareMember: %+v", shareMember)
		err = database.UpdateShareMember(shareMember.ID, map[string]interface{}{"permission": shareMember.Permission}, tx)
		if err != nil {
			for _, rollbackShareMember := range rollbackShareMembers {
				sharePath := pathMap[rollbackShareMember.ID]
				if sharePath.FileType == common.Sync {
					_, subErr := seahub.HandlePostDirSharedItems(sharePath, rollbackShareMember, "user") // rollback
					if subErr != nil {
						klog.Errorf("postgres.HandlePostDirSharedItems error: %v", subErr)
					}
				}
			}
			klog.Errorf("postgres.UpdateShareMember error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}

		sharePath := pathMap[shareMember.ID]
		if sharePath.FileType == common.Sync {
			seaResp, err := seahub.HandlePostDirSharedItems(sharePath, shareMember, "user")
			if err != nil {
				klog.Errorf("postgres.HandlePostDirSharedItems error: %v", err)
				tx.Rollback()
				c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
				return
			}
			klog.Infof("postgres.HandlePostDirSharedItems response: %+v", seaResp)
		}
	}

	// delete
	for _, shareMember := range shareDeletedShareMembers {
		klog.Infof("shareDeletedShareMember: %+v", shareMember)
		err = database.DeleteShareMember(shareMember.MemberId, tx)
		if err != nil {
			// no share path, cannot judge if it is common.Sync
			klog.Errorf("postgres.DeleteShareMember error: %v", err)
			tx.Rollback()
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
	}

	err = tx.Commit().Error
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.UpdateShareMemberPermissionResp)
	resp.Updated = updateShareMembers
	resp.Existed = existedShareMembers
	resp.NotExisted = notExistedShareMembers
	resp.ShareDeleted = shareDeletedShareMembers
	c.JSON(consts.StatusOK, resp)
}

// RemoveShareMember .
// @router /share/share_member/:node/ [DELETE]
func RemoveShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.RemoveShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	memberIdsStr := strings.Split(req.MemberIds, ",")
	memberIds := make([]int64, len(memberIdsStr))
	for i, memberIdStr := range memberIdsStr {
		memberId, err := strconv.ParseInt(memberIdStr, 10, 64)
		if err != nil {
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
			return
		}
		memberIds[i] = memberId
	}

	queryParams := &database.QueryParams{}
	queryParams.OR = []database.Filter{}
	database.BuildIntQueryParam(req.MemberIds, "share_members.id", "=", &queryParams.OR, false)
	memberRes, memberTotal, err := database.QueryShareMember(queryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil || memberTotal == 0 {
		klog.Errorf("QueryShareMember error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	pathQueryParams := &database.QueryParams{}
	pathQueryParams.OR = []database.Filter{}
	for _, shareMember := range memberRes {
		database.BuildStringQueryParam(shareMember.PathID, "share_paths.id", "=", &pathQueryParams.OR, true)
	}
	pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "share_paths.id", "ASC", nil)
	if err != nil || pathTotal == 0 {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}

	var pathMap map[int64]*share.SharePath
	for _, shareMember := range memberRes {
		for _, sharePath := range pathRes {
			if shareMember.PathID == sharePath.ID {
				pathMap[shareMember.ID] = sharePath
				break
			}
		}
	}

	failedMemberIds := []int64{}
	for _, shareMember := range memberRes {
		if sharePath, exist := pathMap[shareMember.ID]; exist {
			// for every share member, it is a individual transaction
			tx := database.DB.Begin()
			if sharePath.FileType == common.Sync {
				seaResp, err := seahub.HandleDeleteDirSharedItems(sharePath, shareMember, "user")
				if err != nil {
					klog.Errorf("postgres.HandleDeleteDirSharedItems error: %v", err)
					tx.Rollback()
					c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
					return
				}
				klog.Infof("postgres.HandleDeleteDirSharedItems response: %+v", seaResp)
			}

			err = database.DeleteShareMember(shareMember.ID, tx)
			if err != nil {
				if sharePath.FileType == common.Sync {
					_, subErr := seahub.HandlePutDirSharedItems(sharePath, []*share.ShareMember{shareMember}, "user") // rollback
					if subErr != nil {
						klog.Errorf("postgres.HandleDeleteDirSharedItems error: %v", subErr)
					}
				}
				tx.Rollback()
				c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
				return
			}

			err = tx.Commit().Error
			if err != nil {
				klog.Errorf("delete share member %d error: %v", shareMember.ID, err)
				failedMemberIds = append(failedMemberIds, shareMember.ID)
			}
		} else {
			err = database.DeleteShareMember(shareMember.ID, database.DB)
			if err != nil {
				klog.Errorf("delete share member %d error: %v", shareMember.ID, err)
				failedMemberIds = append(failedMemberIds, shareMember.ID)
			}
		}
	}

	if len(failedMemberIds) == len(memberIds) {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to delete all identified shared members"})
		return
	}

	if len(failedMemberIds) > 0 {
		failedMemberIdsStr := make([]string, len(failedMemberIds))
		for i, id := range failedMemberIds {
			failedMemberIdsStr[i] = strconv.FormatInt(id, 10)
		}
		c.AbortWithStatusJSON(consts.StatusOK, utils.H{"msg": "Part of identified shared members delete failed: " + strings.Join(failedMemberIdsStr, ",")})
		return
	}

	resp := new(share.RemoveShareMemberResp)
	resp.Success = true
	c.JSON(consts.StatusOK, resp)
}

func ParseTime(t string) string {
	var expireTimeMillis int64
	if _, err := strconv.ParseInt(t, 10, 64); err == nil {
		val, _ := strconv.ParseInt(t, 10, 64)
		expireTimeMillis = val
	} else {
		parsedTime, err := time.Parse(time.RFC3339, t)
		if err != nil {
			return ""
		}
		expireTimeMillis = parsedTime.UnixMilli()
	}
	return time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
}

func DeleteSharePathRelations(pathId string, tx *gorm.DB) error {
	commit := false
	if tx == nil {
		tx = database.DB.Begin()
		commit = true
	}
	pathQueryParams := &database.QueryParams{}
	pathQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(pathId, "share_paths.id", "=", &pathQueryParams.AND, true)
	pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		tx.Rollback()
		return err
	}
	klog.Infof("pathTotal: %d", pathTotal)
	deletePath := pathRes[0]

	tokenQueryParams := &database.QueryParams{}
	tokenQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(pathId, "share_tokens.path_id", "=", &tokenQueryParams.AND, true)
	tokenRes, tokenTotal, err := database.QueryShareToken(tokenQueryParams, 0, 0, "share_tokens.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareToken error: %v", err)
		tx.Rollback()
		return err
	}
	klog.Infof("tokenTotal: %d", tokenTotal)
	for _, shareToken := range tokenRes {
		err = database.DeleteShareToken(shareToken.Token, tx)
		if err != nil {
			klog.Errorf("DeleteShareToken error: %v", err)
			tx.Rollback()
			return err
		}
	}

	memberQueryParams := &database.QueryParams{}
	memberQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(pathId, "share_members.path_id", "=", &memberQueryParams.AND, true)
	memberRes, memberTotal, err := database.QueryShareMember(memberQueryParams, 0, 0, "", "", nil)
	if err != nil {
		klog.Errorf("QueryShareMember error: %v", err)
		tx.Rollback()
		return err
	}
	klog.Infof("memberTotal: %d, deletePath: %s, memberRes: %s", memberTotal, common.ParseString(deletePath), common.ParseString(memberRes))

	if deletePath.FileType == common.Sync {
		for _, shareMember := range memberRes {
			seaResp, err := seahub.HandleDeleteDirSharedItems(deletePath, shareMember, "user")
			if err != nil {
				klog.Errorf("postgres.HandleDeleteDirSharedItems error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("postgres.HandleDeleteDirSharedItems response: %+v", seaResp)
		}
	}

	for _, shareMember := range memberRes {
		err = database.DeleteShareMember(shareMember.ID, tx)
		if err != nil {
			klog.Errorf("DeleteShareMember error: %v", err)
			tx.Rollback()
			return err
		}
	}

	for _, sharePath := range pathRes {
		err = database.DeleteSharePath(sharePath.ID, tx)
		if err != nil {
			klog.Errorf("DeleteSharePath error: %v", err)
			tx.Rollback()
			return err
		}
	}

	if commit {
		return tx.Commit().Error
	}
	return nil
}

func RenameRelativeAdjustShare(fileParam *models.FileParam, dstPath string, dstExtend string, parsePath bool, tx *gorm.DB) error {
	return nil
	commit := false
	if tx == nil {
		tx = database.DB.Begin()
		commit = true
	}
	if strings.HasSuffix(fileParam.Path, "/") &&
		(fileParam.FileType == common.Drive || fileParam.FileType == common.Sync) {
		var err error

		srcPath := fileParam.Path
		if parsePath {
			var srcName, _ = files.GetFileNameFromPath(fileParam.Path)
			srcName, err = url.PathUnescape(srcName)
			if err != nil {
				klog.Errorf("RenameRelativeAdjustShare, PathUnescape error: %v", err)
				tx.Rollback()
				return err
			}
			dstName, err := url.PathUnescape(dstPath)
			if err != nil {
				klog.Errorf("RenameRelativeAdjustShare, PathUnescape error: %v", err)
				tx.Rollback()
				return err
			}
			dstPath = strings.TrimSuffix(fileParam.Path, srcName+"/") + dstName + "/"
		}

		if srcPath != dstPath {
			pathQueryParams := &database.QueryParams{}
			pathQueryParams.AND = []database.Filter{}
			database.BuildStringQueryParam(fileParam.Owner, "share_paths.owner", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(fileParam.FileType, "share_paths.file_type", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(fileParam.Extend, "share_paths.extend", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(fileParam.Path+"%", "share_paths.path", "LIKE", &pathQueryParams.AND, true)
			pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "LENGTH(share_paths.path)", "DESC NULLS LAST", nil)
			if err != nil {
				klog.Errorf("RenameRelativeAdjustShare, QuerySharePath error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("RenameRelativeAdjustShare, pathTotal: %d, pathRes: %s", pathTotal, common.ParseString(pathRes))

			for _, sharePath := range pathRes {
				updatePath := dstPath + strings.TrimPrefix(sharePath.Path, fileParam.Path)
				err = database.UpdateSharePath(sharePath.ID, map[string]interface{}{
					"path":   updatePath,
					"extend": dstExtend,
				}, tx)
				if err != nil {
					klog.Errorf("RenameRelativeAdjustShare, UpdateSharePath error: %v", err)
					tx.Rollback()
					return err
				}
			}
		}
	}
	if commit {
		if err := tx.Commit().Error; err != nil {
			klog.Errorf("RenameRelativeAdjustShare, commit error: %v", err)
			return err
		} else {
			var operator = "add"
			var crd = &share.SmbCreate{
				Owner: fileParam.Owner,
				ID:    uuid.NewString(),
				Path:  fmt.Sprintf("/%s/%s%s", fileParam.FileType, fileParam.Extend, fileParam.Path),
			}

			if err := samba.SambaService.CreateShareSamba([]*share.SmbCreate{crd}, operator); err != nil {
				klog.Errorf("RenameRelativeAdjustShare, modify smb share, error: %v", err)
				return err
			}
		}
	}
	return nil
}

func DeleteRelativeAdjustShare(fileParam *models.FileParam, dirents []string, tx *gorm.DB) error {
	return nil
	commit := false
	if tx == nil {
		tx = database.DB.Begin()
		commit = true
	}

	var smbs []*share.SmbCreate

	if fileParam.FileType == common.Drive || fileParam.FileType == common.Sync {
		klog.Infof("DeleteRelativeAdjustShare, param: %s, dirents: %v", common.ParseString(fileParam), dirents)
		var unsharePaths []string
		for _, dirent := range dirents {
			if strings.HasSuffix(dirent, "/") {
				unsharePaths = append(unsharePaths, fileParam.Path+strings.TrimPrefix(dirent, "/"))
			}
		}
		if len(unsharePaths) > 0 {
			klog.Infof("DeleteRelativeAdjustShare, unsharePaths: %v", unsharePaths)
			pathQueryParams := &database.QueryParams{}
			pathQueryParams.AND = []database.Filter{}
			database.BuildStringQueryParam(fileParam.Owner, "share_paths.owner", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(fileParam.FileType, "share_paths.file_type", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(fileParam.Extend, "share_paths.extend", "=", &pathQueryParams.AND, true)
			pathQueryParams.OR = []database.Filter{}
			for _, dirent := range unsharePaths {
				database.BuildStringQueryParam(dirent+"%", "share_paths.path", "LIKE", &pathQueryParams.OR, true)
			}
			pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "LENGTH(share_paths.path)", "DESC NULLS LAST", nil)
			if err != nil {
				klog.Errorf("DeleteRelativeAdjustShare, QuerySharePath error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("DeleteRelativeAdjustShare, pathTotal: %d, paths: %s", pathTotal, common.ParseString(pathRes))

			var internalSharePaths []*share.SharePath
			var externalSharePaths []*share.SharePath
			var smbSharePaths []*share.SharePath
			for _, sharePath := range pathRes {
				if sharePath.ShareType == common.ShareTypeInternal {
					internalSharePaths = append(internalSharePaths, sharePath)
				} else if sharePath.ShareType == common.ShareTypeExternal {
					externalSharePaths = append(externalSharePaths, sharePath)
				} else if sharePath.ShareType == common.ShareTypeSMB {
					smbSharePaths = append(smbSharePaths, sharePath)
				}
			}

			tokenQueryParams := &database.QueryParams{}
			tokenQueryParams.OR = []database.Filter{}
			for _, sharePath := range externalSharePaths {
				database.BuildStringQueryParam(sharePath.ID, "share_tokens.path_id", "=", &tokenQueryParams.OR, true)
			}
			tokenRes, tokenTotal, err := database.QueryShareToken(tokenQueryParams, 0, 0, "share_tokens.id", "ASC", nil)
			if err != nil {
				klog.Errorf("DeleteRelativeAdjustShare, QueryShareToken error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("DeleteRelativeAdjustShare, tokenTotal: %d", tokenTotal)
			for _, shareToken := range tokenRes {
				err = database.DeleteShareToken(shareToken.Token, tx)
				if err != nil {
					klog.Errorf("DeleteRelativeAdjustShare, DeleteShareToken error: %v", err)
					tx.Rollback()
					continue
				}
			}

			memberQueryParams := &database.QueryParams{}
			memberQueryParams.OR = []database.Filter{}
			for _, sharePath := range internalSharePaths {
				database.BuildStringQueryParam(sharePath.ID, "share_members.path_id", "=", &memberQueryParams.OR, true)
			}
			memberRes, memberTotal, err := database.QueryShareMember(memberQueryParams, 0, 0, "", "", nil)
			if err != nil {
				klog.Errorf("DeleteRelativeAdjustShare, QueryShareMember error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("DeleteRelativeAdjustShare, memberTotal: %d", memberTotal)

			for _, shareMember := range memberRes {
				err = database.DeleteShareMember(shareMember.ID, tx)
				if err != nil {
					klog.Errorf("DeleteRelativeAdjustShare, DeleteShareMember error: %v", err)
					tx.Rollback()
					return err
				}
			}

			// smb
			smbMemberQueryParams := &database.QueryParams{}
			smbMemberQueryParams.OR = []database.Filter{}
			for _, sharePath := range smbSharePaths {
				database.BuildStringQueryParam(sharePath.ID, "share_smb_members.path_id", "=", &smbMemberQueryParams.OR, true)
			}
			smbMemberRes, smbMemberTotal, err := database.QueryShareSmbMember(smbMemberQueryParams, 0, 0, "", "", nil)
			if err != nil {
				klog.Errorf("DeleteRelativeAdjustShare, QueryShareSmbMember error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("DeleteRelativeAdjustShare, smbMemberTotal: %d", smbMemberTotal)

			smbUserQueryParams := &database.QueryParams{}
			smbUserQueryParams.OR = []database.Filter{}
			for _, smbMember := range smbMemberRes {
				database.BuildStringQueryParam(smbMember.UserID, "share_smb_users.user_id", "=", &smbUserQueryParams.OR, true)
			}
			smbUserRes, smbUserTotal, err := database.QueryShareSmbUser(smbUserQueryParams, 0, 0, "", "", nil)
			if err != nil {
				klog.Errorf("DeleteRelativeAdjustShare, QueryShareSmbUser error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("DeleteRelativeAdjustShare, smbUserTotal: %d", smbUserTotal)

			for _, shareSmbMember := range smbMemberRes {
				err = database.DeleteShareSmbMember(shareSmbMember.ID, tx)
				if err != nil {
					klog.Errorf("DeleteRelativeAdjustShare, DeleteShareSmbMember error: %v", err)
					tx.Rollback()
					return err
				}
			}

			for _, smbSharePath := range pathRes {
				var smbRemoveUsres []string
				for _, smbShareMember := range smbMemberRes {
					if smbSharePath.ID != smbShareMember.PathID {
						continue
					}

					for _, smbShareUser := range smbUserRes {
						if smbShareUser.UserID != smbShareMember.UserID {
							continue
						}
						smbRemoveUsres = append(smbRemoveUsres, smbShareUser.UserName)
					}
				}

				var smb = &share.SmbCreate{
					Owner: smbSharePath.Owner,
					ID:    smbSharePath.ID,
					Path:  fmt.Sprintf("/%s/%s%s", smbSharePath.FileType, smbSharePath.Extend, smbSharePath.Path),
				}
				if len(smbRemoveUsres) > 0 {
					smb.User = strings.Join(smbRemoveUsres, ",")
				}
				smbs = append(smbs, smb)
			}

			for _, sharePath := range pathRes {
				err = database.DeleteSharePath(sharePath.ID, tx)
				if err != nil {
					klog.Errorf("DeleteRelativeAdjustShare, DeleteSharePath error: %v", err)
					tx.Rollback()
					return err
				}
			}
		}
	}
	if commit {
		if err := tx.Commit().Error; err != nil {
			return err
		} else {
			if len(smbs) > 0 {
				klog.Infof("DeleteRelativeAdjustShare, create smb crd, data: %s", common.ParseString(smbs))
				if err := samba.SambaService.CreateShareSamba(smbs, "del"); err != nil {
					klog.Errorf("DeleteRelativeAdjustShare, delete share path, create samba DELETE crd error: %v", err)
				}
			}

		}
	}
	return nil
}

func MoveRelativeAdjustShare(action string, src, dst *models.FileParam, tx *gorm.DB) error {
	commit := false
	if tx == nil {
		tx = database.DB.Begin()
		commit = true
	}
	var err error
	if action == "move" && strings.HasSuffix(src.Path, "/") {
		if src.FileType == common.Drive {
			if dst.FileType == common.Drive {
				// just update share info, very like rename
				err = RenameRelativeAdjustShare(src, dst.Path, dst.Extend, false, tx)
				if err != nil {
					klog.Errorf("MoveRelativeAdjustShare drive-drive error: %v", err)
					tx.Rollback()
					return err
				}
			} else if dst.FileType == common.Sync {
				// when internal, create sync share; else remove share info
				pathQueryParams := &database.QueryParams{}
				pathQueryParams.AND = []database.Filter{}
				database.BuildStringQueryParam(src.Owner, "share_paths.owner", "=", &pathQueryParams.AND, true)
				database.BuildStringQueryParam(src.FileType, "share_paths.file_type", "=", &pathQueryParams.AND, true)
				database.BuildStringQueryParam(src.Extend, "share_paths.extend", "=", &pathQueryParams.AND, true)
				database.BuildStringQueryParam(src.Path+"%", "share_paths.path", "LIKE", &pathQueryParams.AND, true)
				pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "LENGTH(share_paths.path)", "DESC NULLS LAST", nil)
				if err != nil {
					klog.Errorf("QuerySharePath error: %v", err)
					tx.Rollback()
					return err
				}
				klog.Infof("pathTotal: %d", pathTotal)

				var internalSharePaths []*share.SharePath // will be updated, and create sync share
				var externalSharePaths []*share.SharePath // will be removed with token removed either
				var smbSharePaths []*share.SharePath      // will be removed
				for _, sharePath := range pathRes {
					if sharePath.ShareType == common.ShareTypeInternal {
						internalSharePaths = append(internalSharePaths, sharePath)
					} else if sharePath.ShareType == common.ShareTypeExternal {
						externalSharePaths = append(externalSharePaths, sharePath)
					} else if sharePath.ShareType == common.ShareTypeSMB {
						smbSharePaths = append(smbSharePaths, sharePath)
					}
				}

				// internal
				memberQueryParams := &database.QueryParams{}
				memberQueryParams.OR = []database.Filter{}
				for _, sharePath := range internalSharePaths {
					database.BuildStringQueryParam(sharePath.ID, "share_members.path_id", "=", &memberQueryParams.OR, true)
				}
				memberRes, memberTotal, err := database.QueryShareMember(memberQueryParams, 0, 0, "", "", nil)
				if err != nil {
					klog.Errorf("QueryShareMember error: %v", err)
					tx.Rollback()
					return err
				}
				klog.Infof("memberTotal: %d", memberTotal)

				for _, sharePath := range pathRes {
					err = database.UpdateSharePath(sharePath.ID, map[string]interface{}{
						"file_type": dst.FileType,
						"extend":    dst.Extend,
						"path":      dst.Path + strings.TrimPrefix(sharePath.Path, src.Path),
					}, tx)
					if err != nil {
						klog.Errorf("UpdateSharePath error: %v", err)
						tx.Rollback()
						return err
					}
					sharePath.FileType = dst.FileType
					sharePath.Extend = dst.Extend
					sharePath.Path = dst.Path + strings.TrimPrefix(sharePath.Path, src.Path)

					shareMembers := []*share.ShareMember{}
					for _, shareMember := range memberRes {
						if shareMember.PathID == sharePath.ID {
							shareMembers = append(shareMembers, shareMember)
						}
					}
					seaResp, err := seahub.HandlePutDirSharedItems(sharePath, shareMembers, "user")
					if err != nil {
						klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
						tx.Rollback()
						return err
					}
					klog.Infof("postgres.HandlePutDirSharedItems response: %+v", seaResp)
				}

				// external
				tokenQueryParams := &database.QueryParams{}
				tokenQueryParams.OR = []database.Filter{}
				for _, sharePath := range externalSharePaths {
					database.BuildStringQueryParam(sharePath.ID, "share_tokens.path_id", "=", &tokenQueryParams.OR, true)
				}
				tokenRes, tokenTotal, err := database.QueryShareToken(tokenQueryParams, 0, 0, "share_tokens.id", "ASC", nil)
				if err != nil {
					klog.Errorf("QueryShareToken error: %v", err)
					tx.Rollback()
					return err
				}
				klog.Infof("tokenTotal: %d", tokenTotal)
				for _, shareToken := range tokenRes {
					err = database.DeleteShareToken(shareToken.Token, tx)
					if err != nil {
						klog.Errorf("DeleteShareToken error: %v", err)
						tx.Rollback()
						return err
					}
				}

				for _, sharePath := range externalSharePaths {
					err = database.DeleteSharePath(sharePath.ID, tx)
					if err != nil {
						klog.Errorf("DeleteSharePath error: %v", err)
						tx.Rollback()
						return err
					}
				}

				// smb
				for _, sharePath := range smbSharePaths {
					err = database.DeleteSharePath(sharePath.ID, tx)
					if err != nil {
						klog.Errorf("DeleteSharePath error: %v", err)
						tx.Rollback()
						return err
					}
				}
			} else {
				// remove share info, very like delete
				// drive relative only operate database, it can be done after real delete
				dir, dirent := filepath.Split(strings.TrimSuffix(src.Path, "/"))
				if !strings.HasSuffix(dir, "/") {
					dir += "/"
				}
				deleteFileParam := &models.FileParam{
					Owner:    src.Owner,
					FileType: src.FileType,
					Extend:   src.Extend,
					Path:     dir,
				}
				dirents := []string{dirent + "/"}
				err = DeleteRelativeAdjustShare(deleteFileParam, dirents, tx)
				if err != nil {
					klog.Errorf("MoveRelativeAdjustShare drive-other error: %v", err)
					tx.Rollback()
					return err
				}
			}
		} else if src.FileType == common.Sync {
			pathQueryParams := &database.QueryParams{}
			pathQueryParams.AND = []database.Filter{}
			database.BuildStringQueryParam(src.Owner, "share_paths.owner", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(src.FileType, "share_paths.file_type", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(src.Extend, "share_paths.extend", "=", &pathQueryParams.AND, true)
			database.BuildStringQueryParam(src.Path+"%", "share_paths.path", "LIKE", &pathQueryParams.AND, true)
			pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "LENGTH(share_paths.path)", "DESC NULLS LAST", nil)
			if err != nil {
				klog.Errorf("QuerySharePath error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("pathTotal: %d", pathTotal)

			memberQueryParams := &database.QueryParams{}
			memberQueryParams.OR = []database.Filter{}
			for _, sharePath := range pathRes {
				database.BuildStringQueryParam(sharePath.ID, "share_members.path_id", "=", &memberQueryParams.OR, true)
			}
			memberRes, memberTotal, err := database.QueryShareMember(memberQueryParams, 0, 0, "", "", nil)
			if err != nil {
				klog.Errorf("QueryShareMember error: %v", err)
				tx.Rollback()
				return err
			}
			klog.Infof("memberTotal: %d", memberTotal)

			if dst.FileType == common.Drive {
				// remove sync share, and update share info
				for _, sharePath := range pathRes {
					err = database.UpdateSharePath(sharePath.ID, map[string]interface{}{
						"file_type": dst.FileType,
						"extend":    dst.Extend,
						"path":      dst.Path + strings.TrimPrefix(sharePath.Path, src.Path),
					}, tx)
					if err != nil {
						klog.Errorf("UpdateSharePath error: %v", err)
						tx.Rollback()
						return err
					}
				}
			} else if dst.FileType == common.Sync {
				// update sync share (same repo don't need) and share info
				for _, sharePath := range pathRes {
					err = database.UpdateSharePath(sharePath.ID, map[string]interface{}{
						"file_type": dst.FileType,
						"extend":    dst.Extend,
						"path":      dst.Path + strings.TrimPrefix(sharePath.Path, src.Path),
					}, tx)
					if err != nil {
						klog.Errorf("UpdateSharePath error: %v", err)
						tx.Rollback()
						return err
					}
					if src.Extend != dst.Extend {
						sharePath.Extend = dst.Extend
						sharePath.Path = dst.Path + strings.TrimPrefix(sharePath.Path, src.Path)
						// diff repo, need to remove sync share and create sync share (sync share update only support permission update)
						for _, shareMember := range memberRes {
							if shareMember.PathID == sharePath.ID {
								// seafile auto unshare, no need to delete, just put a new share
								seaResp, err := seahub.HandlePutDirSharedItems(sharePath, []*share.ShareMember{shareMember}, "user")
								if err != nil {
									klog.Errorf("postgres.HandlePutDirSharedItems error: %v", err)
									tx.Rollback()
									return err
								}
								klog.Infof("postgres.HandlePutDirSharedItems response: %+v", seaResp)
							}
						}
					}
				}
			} else {
				// remove share info
				for _, sharePath := range pathRes {
					err = DeleteSharePathRelations(sharePath.ID, tx)
					if err != nil {
						klog.Errorf("DeleteSharePathRelations error: %v", err)
						tx.Rollback()
						return err
					}
					err = database.DeleteSharePath(sharePath.ID, tx)
					if err != nil {
						klog.Errorf("deleteSharePath error: %v", err)
						tx.Rollback()
						return err
					}
				}
			}
		}
	}
	if commit {
		return tx.Commit().Error
	}
	return nil
}

func RemoveUserRelativeAdjustShare(bflName string, tx *gorm.DB) error {
	commit := false
	if tx == nil {
		tx = database.DB.Begin()
		commit = true
	}

	// delete shared by me
	pathQueryParams := &database.QueryParams{}
	pathQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(bflName, "share_paths.owner", "=", &pathQueryParams.AND, true)
	pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "LENGTH(share_paths.path)", "DESC NULLS LAST", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		tx.Rollback()
		return err
	}
	klog.Infof("pathTotal: %d", pathTotal)

	for _, sharePath := range pathRes {
		err = DeleteSharePathRelations(sharePath.ID, tx)
		if err != nil {
			klog.Errorf("DeleteSharePath error: %v", err)
			tx.Rollback()
			return err
		}

		err = database.DeleteSharePath(sharePath.ID, tx)
		if err != nil {
			tx.Rollback()
			return err
		}
	}

	// delete share to me
	memberQueryParams := &database.QueryParams{}
	memberQueryParams.AND = []database.Filter{}
	database.BuildStringQueryParam(bflName, "share_members.share_member", "=", &memberQueryParams.AND, true)

	shareMembers, _, err := database.QueryShareMember(memberQueryParams, 0, 0, "share_members.id", "ASC", nil)
	if err != nil {
		klog.Errorf("QueryShareMember error: %v", err)
		return err
	}

	inPathQueryParams := &database.QueryParams{}
	inPathQueryParams.OR = []database.Filter{}
	for _, shareMember := range shareMembers {
		database.BuildStringQueryParam(shareMember.PathID, "share_paths.id", "=", &inPathQueryParams.OR, true)
	}
	inPathRes, inPathTotal, err := database.QuerySharePath(inPathQueryParams, 0, 0, "LENGTH(share_paths.path)", "DESC NULLS LAST", nil)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		tx.Rollback()
		return err
	}
	klog.Infof("inPathTotal: %d", inPathTotal)

	inPathMap := make(map[int64]*share.SharePath)
	for _, shareMember := range shareMembers {
		for _, inPath := range inPathRes {
			if shareMember.PathID == inPath.ID {
				inPathMap[shareMember.ID] = inPath
				break
			}
		}
	}

	for _, shareMember := range shareMembers {
		if inPath, exists := inPathMap[shareMember.ID]; exists {
			if inPath.FileType == common.Sync {
				seaResp, err := seahub.HandleDeleteDirSharedItems(inPath, shareMember, "user")
				if err != nil {
					klog.Errorf("postgres.HandleDeleteDirSharedItems error: %v", err)
					// when user real deleted, seafile share relation is also removed, no need to breakdown at the time of error here
				} else {
					klog.Infof("postgres.HandleDeleteDirSharedItems response: %+v", seaResp)
				}
			}
		}
		err = database.DeleteShareMember(shareMember.ID, tx)
		if err != nil {
			klog.Errorf("postgres.DeleteShareMember error: %v", err)
			tx.Rollback()
			return err
		}
	}

	if commit {
		return tx.Commit().Error
	}
	return nil
}

// GetToken .
// @router /api/share/get_token/ [POST]
func GetToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.GetTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	klog.Infof("GetToken, shareId: %s", req.ShareId)

	sharePath, err := database.QueryShareById(req.ShareId)
	if err != nil {
		klog.Errorf("GetToken, query share failed, shareId: %s, error: %v", req.ShareId, err)
		handler.RespError(c, fmt.Sprintf("GetToken Error, %v", err))
		return
	}

	if sharePath == nil {
		klog.Errorf("GetToken, share path not found, shareId: %s", req.ShareId)
		handler.RespError(c, common.ErrorMessageWrongShare)
		return
	}

	if sharePath.ShareType != common.ShareTypeExternal {
		klog.Errorf("GetToken, shareType %s invalid, shareId: %s", sharePath.ShareType, req.ShareId)
		handler.RespError(c, common.ErrorMessageWrongShare)
		return
	}

	if common.Md5String(req.Password) != sharePath.PasswordMd5 {
		handler.RespError(c, common.ErrorMessageWrongPassword)
		return
	}

	klog.Infof("GetToken, sharePath expireTime: %s, shareId: %s", sharePath.ExpireTime, req.ShareId)

	expireTime, _ := time.Parse(time.RFC3339Nano, sharePath.ExpireTime)
	if time.Now().After(expireTime) {
		handler.RespErrorExpired(c, common.CodeLinkExpired, common.ErrorMessageLinkExpired, expireTime.Unix())
		return
	}

	// create token
	var token = &share.ShareToken{
		PathID:   req.ShareId,
		ExpireAt: time.Now().Add(6 * time.Hour).Format(time.RFC3339Nano),
	}

	res, err := database.CreateShareToken([]*share.ShareToken{token}, database.DB)
	if err != nil {
		klog.Errorf("GetToken generate token error: %v, shareId: %s", err, req.ShareId)
		handler.RespError(c, common.ErrorMessageGetTokenError)
		return
	}

	defaultToken := res[0]

	var result = make(map[string]interface{})
	result["code"] = 0
	result["data"] = defaultToken.Token

	klog.Infof("GetToken, get external shared, shareId: %s, token: %s", req.ShareId, defaultToken.Token)

	c.JSON(consts.StatusOK, result)
}

// GetSharePath .
// @router /api/share/get_share/ [GET]
func GetExternalSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.GetExternalSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	shareToken, err := database.GetShareToken(req.Token)
	if err != nil {
		klog.Errorf("GetSharePath, get token error: %v", err)
		handler.RespErrorExpired(c, common.CodeTokenExpired, common.ErrorMessageTokenExpired, time.Now().Unix())
		return
	}

	expired, _ := time.Parse(time.RFC3339Nano, shareToken.ExpireAt)
	if time.Now().After(expired) {
		handler.RespErrorExpired(c, common.CodeTokenExpired, common.ErrorMessageTokenExpired, expired.Unix())
		return
	}

	sharePath, err := database.GetSharePath(req.PathId)
	if err != nil {
		klog.Errorf("GetSharePath, get path error: %v", err)
		handler.RespErrorExpired(c, common.CodeLinkExpired, common.ErrorMessageLinkExpired, time.Now().Unix())
	}

	expired, _ = time.Parse(time.RFC3339Nano, sharePath.ExpireTime)
	if time.Now().After(expired) {
		handler.RespErrorExpired(c, common.CodeLinkExpired, common.ErrorMessageLinkExpired, expired.Unix())
		return
	}

	var result = make(map[string]interface{})
	result["id"] = sharePath.ID
	result["name"] = sharePath.Name
	result["file_type"] = sharePath.FileType
	result["extend"] = sharePath.Extend
	result["path"] = sharePath.Path
	result["owner"] = sharePath.Owner
	result["share_type"] = sharePath.ShareType
	result["permission"] = sharePath.Permission
	result["upload_size_limit"] = sharePath.UploadSizeLimit
	result["expire_in"] = sharePath.ExpireIn
	result["expire_time"] = sharePath.ExpireTime
	result["create_time"] = sharePath.CreateTime
	result["update_time"] = sharePath.UpdateTime

	handler.RespSuccess(c, result)
}

// ResetPassword .
// @router /api/share/share_password/ [PUT]
func ResetPassword(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ResetPasswordReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	klog.Infof("[samba] ResetPassword, data: %s", req.PathId)

	sharePath, err := database.QueryShareById(req.PathId)
	if err != nil {
		klog.Errorf("ResetPassword, querySharePath error: %v", err)
		handler.RespError(c, fmt.Sprintf("ResetPassword Error: %v", err))
	}

	if sharePath == nil {
		handler.RespError(c, common.ErrorMessageWrongShare)
		return
	}

	sharePath.PasswordMd5 = common.Md5String(req.Password)

	if err = database.ResetExternalSharePasswordTx(sharePath); err != nil {
		klog.Errorf("ResetPassword, update error: %v", err)
		return
	}

	handler.RespSuccess(c, nil)
}

// ListSmbShareUser .
// @router /api/share/smb_share_users/ [GET]
func ListSmbUser(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListSmbUserReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	res, err := database.QuerySmbUsers(owner, nil)
	if err != nil {
		handler.RespError(c, err.Error())
		return
	}

	var data = make([]map[string]string, 0)
	for _, r := range res {
		p, _ := common.Base64Decode(r.Password)
		var d = make(map[string]string)
		d["id"] = r.UserID
		d["name"] = r.UserName
		d["password"] = p
		data = append(data, d)
	}

	handler.RespSuccess(c, data)
}

// CreateSmbUser .
// @router /api/share/smb_share_user/ [POST]
func CreateSmbUser(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.CreateSmbUserReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	var userId = uuid.New().String()
	var userName = req.User
	var password = common.Base64Encode(req.Password)

	err = database.CreateSmbUser(owner, userId, userName, password)
	if err != nil {
		if !strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			handler.RespError(c, fmt.Sprintf("Create User Error %v", err))
			return
		}

		handler.RespError(c, common.ErrorMessageUserExists)
		return
	}

	var result = make(map[string]string)
	result["id"] = userId
	result["name"] = userName
	result["password"] = req.Password

	handler.RespSuccess(c, result)
}

// DeleteSmbUser .
// @router /api/share/smb_share_user/ [DELETE]
func DeleteSmbUser(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.DeleteSmbUserReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	// all samba shares linked to the deleted users
	relSmbUserShares, err := database.QuerySmbShares(owner, common.ShareTypeSMB, nil, req.Users)
	if err != nil {
		klog.Errorf("[samba] DeleteSmbUser, query users shares error: %v", err)
		handler.RespError(c, common.ErrorMessageWrongShare)
		return
	}

	klog.Infof("[samba] DeleteSmbUser, data: %s, relshares: %s", common.ParseString(req), common.ParseString(relSmbUserShares))

	if err := samba.SambaService.DeleteSambaShareUsers(owner, req.Users); err != nil {
		klog.Errorf("[samba] DeleteSmbUser, delete users error: %v", err)
		handler.RespError(c, fmt.Sprintf("Delete User Error: %v", err))
		return
	}

	if len(relSmbUserShares) > 0 {
		var smbs []*share.SmbCreate
		for _, item := range relSmbUserShares {
			if item.SmbSharePublic == 1 {
				// in theory, there shouldnt be any public Samba shares here.
				continue
			}
			if item.UserName == "" {
				continue
			}

			var smb = &share.SmbCreate{
				Owner: item.Owner,
				ID:    item.ID,
				Path:  fmt.Sprintf("/%s/%s%s", item.FileType, item.Extend, item.Path),
				User:  item.UserName,
			}
			smbs = append(smbs, smb)
		}

		if err := samba.SambaService.CreateShareSamba(smbs, "deluser"); err != nil {
			klog.Errorf("[samba] DeleteSmbUser, write deluser crd failed, owner: %s, error: %s", owner, err)
			handler.RespError(c, fmt.Sprintf("Delete User Error: %v", err))
			return
		}
	}

	handler.RespSuccess(c, nil)
}

// ~ internal func
func createSambaShare(c *app.RequestContext, owner string, req *share.CreateSharePathReq, fileParam *models.FileParam) {
	klog.Infof("[samba] CreateSharePath, samba, owner: %s, data: %s", owner, common.ParseString(fileParam))

	var isSmbSharePublic int32
	if req.PublicSmb {
		isSmbSharePublic = 1
	}

	result, err := samba.SambaService.CreateSambaSharePath(owner, isSmbSharePublic, req.Users, fileParam, req.ExpireIn, req.ExpireTime)
	if err != nil {
		klog.Errorf("[share] CreateSharePath, create smb share failed, owner: %s, error: %v", owner, err)
		handler.RespError(c, fmt.Sprintf("Create Smb Share Error %v", err))
		return
	}

	var shareItem = &share.SmbCreate{
		Owner: owner,
		ID:    result.ID,
		Path:  fmt.Sprintf("/%s/%s%s", result.FileType, result.Extend, result.Path),
		User:  "", // not use
	}

	var shareItems = []*share.SmbCreate{shareItem}
	if err := samba.SambaService.CreateShareSamba(shareItems, "add"); err != nil {
		klog.Errorf("[share] CreateSharePath, create smb share crd failed, owner: %s, error: %v", owner, err)
		handler.RespError(c, fmt.Sprintf("Create Samba Share Res Error: %v", err))
		return
	}

	var data = &share.ViewSharePath{
		ID:         result.ID,
		Owner:      result.Owner,
		FileType:   fileParam.FileType,
		Extend:     fileParam.Extend,
		Path:       fileParam.Path,
		ShareType:  common.ShareTypeSMB,
		Name:       result.Name,
		ExpireIn:   result.ExpireIn,
		ExpireTime: result.ExpireTime,
		Permission: result.Permission,
		CreateTime: result.CreateTime,
		UpdateTime: result.UpdateTime,
		SharedByMe: true,
		SmbLink:    fmt.Sprintf("smb://%s/%s", os.Getenv("NODE_IP"), result.Name),
	}

	handler.RespSuccess(c, data)
}

// ModifySmbMember .
// @router /api/share/smb_share_member/ [POST]
func ModifySmbMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ModifySmbMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		handler.RespError(c, err.Error())
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	klog.Infof("[samba] ModifySmbMember, req: %s", common.ParseString(req))

	shared, err := database.GetSharePath(req.PathId)
	if err != nil {
		handler.RespError(c, common.ErrorMessageWrongShare)
		return
	}

	if shared == nil {
		handler.RespError(c, common.ErrorMessageWrongShare)
		return
	}

	if shared.SmbSharePublic == 1 && req.PublicSmb {
		handler.RespSuccess(c, nil)
		return
	}

	if err = samba.SambaService.ModifySambaShareMembers(owner, req.PublicSmb, shared, req.Users); err != nil {
		klog.Errorf("[samba] ModifySmbMember, failed, owner: %s, pathId: %s, error: %v", owner, req.PathId, err)
		handler.RespError(c, fmt.Sprintf("Modify Members Error: %v", err))
		return
	}

	handler.RespSuccess(c, req.Users)
}

// GetInternalSmbSharePath .
// @router /api/share/get_share_internal_smb/ [GET]
func GetInternalSmbSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var sharePath = c.Param("path")
	var shareType = c.Query("share_type")

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	klog.Infof("[samba] GetInternalSmbSharePath, owner: %s, path: %s, type: %s", owner, sharePath, shareType)

	if !common.ListContains([]string{common.ShareTypeInternal, common.ShareTypeSMB}, shareType) {
		handler.RespError(c, common.ErrorMessageShareTypeInvalid)
		return
	}

	fileParam, err := models.CreateFileParam(owner, sharePath)
	if err != nil {
		handler.RespError(c, common.ErrorMessagePathInvalid)
		return
	}

	res, err := database.GetInternalSmbSharePath(owner, shareType, fileParam.FileType, fileParam.Extend, fileParam.Path)
	if err != nil {
		klog.Errorf("[samba] GetInternalSmbSharePath, get error: %v", err)
		handler.RespError(c, fmt.Sprintf("Get Share Path Error: %v", err))
		return
	}

	handler.RespSuccess(c, res)
}

// used for move files
func UpdateMovedSharePaths(owner string, src *models.FileParam, dst *models.FileParam) error {
	// /drive/Home/ --> /drive/Home/     smb update
	// /drive/Home/ --> /drive/Data/     smb update
	// /drive/Data/ --> /drive/Data/     smb update
	// /drive/Data/ --> /drive/Home/     smb update
	// /drive/xxxx/ --> /sync/xxxx/      smb update
	// /sync/xxxx/  --> /sync/xxxx/
	// /sync/xxxx/  --> /drive/xxxx/

	if !((src.FileType == common.Drive || src.FileType == common.Sync) && (dst.FileType == common.Drive || dst.FileType == common.Sync)) {
		return nil
	}

	klog.Infof("UpdateMovedSharePaths, prepared, owner: %s, src: %s, dst: %s", owner, common.ParseString(src), common.ParseString(dst))

	shared, err := database.GetSmbSharePathByPrefix(src.FileType, src.Extend, src.Path, owner)
	if err != nil {
		klog.Errorf("UpdateMovedSharePaths, get paths error: %v", err)
		return err
	}

	if len(shared) == 0 {
		return nil
	}

	var updates = make(map[string][5]string)

	var srcPath = src.FileType + "/" + src.Extend + src.Path
	var dstPath string
	var smbUpdated bool

	for _, share := range shared {
		var sharedPath = share.FileType + "/" + share.Extend + share.Path
		if strings.HasPrefix(sharedPath, srcPath) {
			var smbOperator string
			if share.ShareType == common.ShareTypeSMB {
				if dst.FileType == common.Sync {
					smbOperator = "del"
				}
				smbUpdated = true
			}

			var tmp = strings.TrimPrefix(sharedPath, srcPath)
			dstPath = dst.Path + strings.TrimPrefix(tmp, "/")
			var m = [5]string{share.ShareType, smbOperator, dst.FileType, dst.Extend, dstPath}

			updates[share.ID] = m
		}
	}

	klog.Infof("UpdateMovedSharePaths, updates: %s", common.ParseString(updates))

	if len(updates) > 0 {
		if err := database.UpdateMovedChangeSharePathsEx(updates); err != nil {
			klog.Errorf("UpdateMovedSharePaths, update changes error: %v", err)
			return err
		}
	}

	if smbUpdated {
		var smbCreate = &share.SmbCreate{
			Owner: owner,
			ID:    uuid.NewString(),
			Path:  "/",
		}
		if err := samba.SambaService.CreateShareSamba([]*share.SmbCreate{smbCreate}, "add"); err != nil {
			klog.Errorf("UpdateMovedSharePaths, update samba config error: %v", err)
			return nil
		}
	}

	return nil
}
