// Code generated by hertz generator.

package preview

import (
	"bytes"
	"context"
	"files/pkg/common"
	"files/pkg/drivers"
	"files/pkg/drivers/base"
	preview "files/pkg/hertz/biz/model/api/preview"
	"files/pkg/models"
	"fmt"
	"mime"
	"strings"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"k8s.io/klog/v2"
)

// PreviewMethod .
// @router /api/preview/*path [GET]
func PreviewMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var req preview.PreviewReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	_ = new(preview.PreviewResp) // file stream, won't use
	contextArg, err := models.NewHttpContextArgs(ctx, c, "/api/preview/", false, false)
	if err != nil {
		klog.Errorf("context args error: %v, path: %s", err, string(c.Path()))
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	klog.Infof("[Incoming] preview, user: %s, fsType: %s, method: %s, args: %s", contextArg.FileParam.Owner, contextArg.FileParam.FileType, c.Method(), common.ToJson(contextArg))

	var handlerParam = &base.HandlerParam{
		Ctx:   ctx,
		Owner: contextArg.FileParam.Owner,
	}

	var fileType = contextArg.FileParam.FileType
	var handler = drivers.Adaptor.NewFileHandler(fileType, handlerParam)

	if handler == nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("handler not found, type: %s", contextArg.FileParam.FileType)})
		return
	}

	if contextArg.FileParam.FileType == common.AwsS3 ||
		contextArg.FileParam.FileType == common.DropBox ||
		contextArg.FileParam.FileType == common.GoogleDrive {
		if contextArg.QueryParam.PreviewSize == "thumb" {
			c.SetStatusCode(consts.StatusOK)
			return
		}
	}

	fileData, err := handler.Preview(contextArg)
	if err != nil {
		klog.Errorf("preview error: %v, user: %s, url: %s", err, contextArg.FileParam.Owner, strings.TrimPrefix(string(c.Path()), "/api/preview/"))
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{
			"code":    1,
			"message": err.Error(),
		})
		return
	}

	c.Header("Content-Disposition", mime.FormatMediaType("inline", map[string]string{
		"filename": fileData.FileName,
	}))

	if !fileData.IsCloud {
		c.Header("Last-Modified", fileData.FileModified.UTC().Format(time.RFC1123))
		ifMatch := string(c.GetHeader("If-Modified-Since"))
		if ifMatch != "" {
			t, _ := time.Parse(time.RFC1123, ifMatch)
			if !fileData.FileModified.After(t) {
				c.AbortWithStatusJSON(consts.StatusNotModified, utils.H{
					"message": "file not modified",
				})
				return
			}
		}
		if !contextArg.FileParam.IsSync() {
			c.SetContentType(common.MimeTypeByExtension(fileData.FileName)) // todo temp
		} else {
			name, ext := common.SplitNameExt(fileData.FileName)
			ext = strings.ToLower(ext)
			if ext == ".jpg" || ext == ".jpeg" || ext == ".gif" || ext == ".tiff" || ext == ".heic" {
				c.SetContentType(common.MimeTypeByExtension(fileData.FileName))
			} else {
				c.SetContentType(common.MimeTypeByExtension(name + ".png"))
			}
		}
		c.SetBodyStream(bytes.NewReader(fileData.Data), len(fileData.Data))
	} else {
		for k, vs := range fileData.RespHeader {
			for _, v := range vs {
				c.Header(k, v)
			}
		}
		c.SetContentType(common.MimeTypeByExtension(fileData.FileName))
		c.SetStatusCode(fileData.StatusCode)
		c.SetBodyStream(bytes.NewReader(fileData.Data), len(fileData.Data))
	}
}
