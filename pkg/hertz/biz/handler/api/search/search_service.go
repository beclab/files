// Code generated by hertz generator.

package search

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"

	"files/pkg/common"
	"files/pkg/files"
	"files/pkg/hertz/biz/dal/database"
	search "files/pkg/hertz/biz/model/api/search"
	"files/pkg/models"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"k8s.io/klog/v2"
)

// Search .
// @router /api/search [POST]
func Search(ctx context.Context, c *app.RequestContext) {
	var err error
	var req search.SearchReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	internalShared, externalShared, err := database.QuerySearchSharedDirectories(owner)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("search failed, error: %v", err)})
		return
	}

	klog.Infof("search, internalPaths count: %d, externalPaths count: %d", len(internalShared), len(externalShared))

	// todo /share/{share_id}/, read | write
	// todo /drive/Home/, /drive/Data/, /cache/{node}/, /external/{node}/

	var sharePaths []string

	for _, esp := range externalShared {
		sharePaths = append(sharePaths, esp.Path)
	}

	for _, isp := range internalShared {
		sharePaths = append(sharePaths, isp.Path)
	}

	watchPaths := files.GetCommonPath(sharePaths)

	klog.Infof("search, sharedPaths cound: %d", len(watchPaths))

	// call search service
	var searchUrl = "" // todo
	var header = make(map[string]string)
	var data = make(map[string]interface{})

	data["reqId"] = req.ReqId
	data["keyword"] = req.Keyword
	data["type"] = req.Type
	data["app"] = req.App
	data["user"] = owner
	data["canWatchPath"] = watchPaths
	data["limit"] = req.Limit
	data["offset"] = req.Offset

	_, err = common.Request(searchUrl, http.MethodPost, header, data, true)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("search failed, error: %v", err)})
		return
	}

	c.JSON(consts.StatusOK, watchPaths)

}

// GetAuthorityDirectories .
// @router /api/authority [POST]
func GetAuthorityDirectories(ctx context.Context, c *app.RequestContext) {
	/**
	 * /drive/Home/
	 * /drive/Data/
	 * /cache/{node}/
	 * /external/{node}/
	 */
	var err error
	var req search.GetAuthorityDirectoriesReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(search.GetAuthorityDirectoriesResp)

	c.JSON(consts.StatusOK, resp)
}

// CheckCheckDirectoryAuthority .
// @router /api/authority [PUT]
func CheckCheckDirectoryAuthority(ctx context.Context, c *app.RequestContext) {
	var err error
	var req search.CheckDirectoryAuthorityReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	fileParam, err := models.CreateFileParam(req.User, req.Path)
	if err != nil {
		return
	}

	uri, err := fileParam.GetResourceUri()
	if err != nil {
		return
	}

	read := CanReadDir(uri)
	write := CanWriteDir(uri)

	var result = &search.CheckDirectoryAuthorityResp{
		Read_:  read,
		Write_: write,
	}

	c.JSON(consts.StatusOK, result)
}

func CanReadDir(dir string) bool {
	f, err := os.Open(dir)
	if err != nil {
		return false
	}
	defer f.Close()
	_, err = f.Readdirnames(1)
	return err == nil || errors.Is(err, io.EOF)
}

func CanWriteDir(dir string) bool {
	tmp := filepath.Join(dir, fmt.Sprintf(".permcheck_tmp_%d", time.Now().Nanosecond()))
	f, err := os.OpenFile(tmp, os.O_CREATE|os.O_EXCL|os.O_WRONLY, 0o600)
	if err != nil {
		return false
	}
	f.Close()
	_ = os.Remove(tmp)
	return true
}
