// Code generated by hertz generator.

package search

import (
	"context"
	"encoding/json"
	"files/pkg/drivers/sync/seahub"
	"fmt"
	"strings"

	"files/pkg/common"
	"files/pkg/global"
	"files/pkg/hertz/biz/dal/database"
	"files/pkg/hertz/biz/handler"
	search "files/pkg/hertz/biz/model/api/search"
	"files/pkg/models"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"k8s.io/klog/v2"
)

// GetDirectories .
// @router /api/search/get_directory/ [POST]
func GetDirectories(ctx context.Context, c *app.RequestContext) {
	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	klog.Infof("[search] GetDirectories, owner: %s", owner)

	nodes := global.GlobalNode.GetNodes()

	internalShares, externalShares, err := database.QuerySearchSharedDirectories(owner)
	if err != nil {
		klog.Errorf("[search] GetDirectories, owner: %s, query shares error: %v", owner, err)
		handler.RespError(c, fmt.Sprintf("Query Shares Error: %v", err))
		return
	}

	var result []*search.DirectoryInfo
	for _, s := range internalShares {
		if s.Owner != owner {
			var di = &search.DirectoryInfo{
				Path:       fmt.Sprintf("/%s/%s/%s/", s.FileType, s.Extend, strings.Trim(s.Path, "/")),
				SharePath:  fmt.Sprintf("/share/%s/", s.ID),
				Owner:      s.Owner,
				Permission: s.Permission,
			}
			result = append(result, di)
		}
	}
	for _, s := range externalShares {
		if s.Owner != owner {
			var di = &search.DirectoryInfo{
				Path:       fmt.Sprintf("/%s/%s/%s/", s.FileType, s.Extend, strings.Trim(s.Path, "/")),
				SharePath:  fmt.Sprintf("/share/%s/", s.ID),
				Owner:      s.Owner,
				Permission: s.Permission,
			}
			result = append(result, di)
		}
	}

	for _, n := range nodes {
		result = append(result, &search.DirectoryInfo{
			Path:       fmt.Sprintf("/cache/%s/", n.Name),
			Owner:      owner,
			Permission: 4,
		}, &search.DirectoryInfo{
			Path:       fmt.Sprintf("/external/%s/", n.Name),
			Owner:      owner,
			Permission: 4,
		})
	}

	result = append(result,
		&search.DirectoryInfo{
			Path:       "/drive/Home/",
			Owner:      owner,
			Permission: 4,
		},
		&search.DirectoryInfo{
			Path:       "/drive/Data/",
			Owner:      owner,
			Permission: 4,
		},
	)

	klog.Infof("[search] GetDirectories, owner: %s, result: %v", owner, common.ParseString(result))

	handler.RespSuccess(c, result)
}

// CheckDirectory .
// @router /api/search/check_directory/*path [POST]
func CheckDirectory(ctx context.Context, c *app.RequestContext) {
	var sharePath = c.Param("path")

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	fileParam, err := models.CreateFileParam(owner, sharePath)
	if err != nil {
		handler.RespError(c, common.ErrorMessagePathInvalid)
		return
	}

	fileParam.Extend = common.TrimShareId(fileParam.Extend)

	var permission int32

	if fileParam.FileType == common.Share {
		shared, err := database.GetSharePath(fileParam.Extend)
		if err != nil {
			klog.Errorf("[search] CheckDirectory, get share failed, owner: %s, error: %v", owner, err)
			handler.RespError(c, fmt.Sprintf("Check Directory Error: %v", err))
			return
		}

		if shared == nil {
			handler.RespError(c, common.ErrorMessageShareNotExists)
			return
		}

		if shared.FileType == common.Sync {
			handler.RespError(c, common.ErrorMessageSyncNotSupport)
			return
		}

		member, err := database.GetShareMember(shared.ID, owner)
		if err != nil {
			klog.Errorf("[search] CheckDirectory, get member failed, owner: %s, error: %v", owner, err)
			handler.RespError(c, fmt.Sprintf("Check Directory Error: %v", err))
			return
		}

		if member == nil {
			permission = 0
		} else if member.Permission == 1 {
			permission = 1
		} else {
			permission = 3
		}
	} else {
		permission = 3
	}

	if !strings.HasPrefix(sharePath, "/") {
		sharePath = "/" + sharePath
	}

	var result = &search.CheckDirectoryResp{
		Path:       sharePath,
		Permission: permission,
	}

	handler.RespSuccess(c, result)
}

// SyncSearch .
// @router /api/search/sync_search/ [POST]
func SyncSearch(ctx context.Context, c *app.RequestContext) {
	var err error
	var req search.SyncSearchReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		handler.RespError(c, common.ErrorMessageOwnerNotFound)
		return
	}

	res, err := seahub.HandleSearch(owner, req.Q)
	klog.Infof("[sync search] res=%s", string(res))

	resp := new(search.SyncSearchResp)
	if err := json.Unmarshal(res, &resp); err != nil {
		klog.Errorf("Failed to unmarshal response body: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
		return
	}
	c.JSON(consts.StatusOK, resp)
}
