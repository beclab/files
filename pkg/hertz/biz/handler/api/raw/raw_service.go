// Code generated by hertz generator.

package raw

import (
	"context"
	"files/pkg/common"
	"files/pkg/drivers"
	"files/pkg/drivers/base"
	"files/pkg/files"
	raw "files/pkg/hertz/biz/model/api/raw"
	"files/pkg/models"
	"fmt"
	"mime"
	"path"
	"strings"
	"sync"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"k8s.io/klog/v2"
)

var noCacheFilesExt = []string{
	"txt", "py", "c", "cpp", "java", "js", "ts", "php", "sql",
	"html", "htm", "css", "sh", "swift", "m", "cs", "go",
	"rb", "pl", "pm", "lua", "vbp", ".for", "f90", "pas",
	"dpr", "rs", "asm", "kt", "r", "sb3", "epub",
}

var noCacheFilesMap sync.Map

func init() {
	for _, name := range noCacheFilesExt {
		noCacheFilesMap.Store(fmt.Sprintf(".%s", name), 1)
	}
}

// RawMethod .
// @router /api/raw/*path [GET]
func RawMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var req raw.RawReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	var share = req.Share

	_ = new(raw.RawResp) // file stream, won't use
	contextArg, err := models.NewHttpContextArgs(ctx, c, "/api/raw", false, false)
	if err != nil {
		klog.Errorf("context args error: %v, path: %s", err, string(c.Path()))
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	klog.Infof("[Incoming] raw, user: %s, fsType: %s, method: %s, args: %s", contextArg.FileParam.Owner, contextArg.FileParam.FileType, c.Method(), common.ToJson(contextArg))

	var handlerParam = &base.HandlerParam{
		Ctx:   ctx,
		Owner: contextArg.FileParam.Owner,
	}

	var rawInline = ""
	if req.Inline != nil {
		rawInline = *req.Inline
	}
	var rawMeta = ""
	if req.Meta != nil {
		rawMeta = *req.Meta
	}
	var fileType = contextArg.FileParam.FileType
	var fileName, isFile = files.GetFileNameFromPath(contextArg.FileParam.Path)
	if !isFile {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("not a file, path: %s", contextArg.FileParam.Path)})
		return
	}

	var fileExt = path.Ext(fileName)
	var noCache bool
	_, ok := noCacheFilesMap.Load(fileExt)
	if ok {
		noCache = true
	}

	var handler = drivers.Adaptor.NewFileHandler(fileType, handlerParam)
	if handler == nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("handler not found, type: %s", contextArg.FileParam.FileType)})
		return
	}

	file, err := handler.Raw(contextArg)
	if err != nil {
		klog.Errorf("raw error: %v, user: %s, url: %s", err, contextArg.FileParam.Owner, strings.TrimPrefix(string(c.Path()), "/api/raw"))
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{
			"code":    1,
			"message": err.Error(),
		})
		return
	}

	if rawInline == "true" {
		if rawMeta == "true" {
			c.SetContentType("application/json; charset=utf-8")
		} else {
			c.SetContentType(common.MimeTypeByExtension(file.FileName))
		}
		if !noCache {
			c.Header("Cache-Control", "private")
		}

		c.Header("Content-Disposition", mime.FormatMediaType("inline", map[string]string{
			"filename": file.FileName,
		}))

	} else {
		c.Header("Content-Disposition", mime.FormatMediaType("attachment", map[string]string{
			"filename": file.FileName,
		}))
	}

	if file.Redirect {
		var redirectHost = file.FileName
		if share == "1" {
			redirectHost = fmt.Sprintf("http://127.0.0.1%s", file.FileName)
		}
		klog.Infof("redirect to %s", redirectHost)
		c.Redirect(consts.StatusFound, []byte(redirectHost))
		return
	}

	if !file.IsCloud {
		if !noCache {
			c.Header("Last-Modified", file.FileModified.UTC().Format(time.RFC1123))
			ifMatch := string(c.GetHeader("If-Modified-Since"))
			if ifMatch != "" {
				t, _ := time.Parse(time.RFC1123, ifMatch)
				if !file.FileModified.After(t) {
					c.AbortWithStatusJSON(consts.StatusNotModified, utils.H{
						"message": "file not modified",
					})
					return
				}
			}
		} else {
			c.Header("Cache-Control", "no-store, no-cache, must-revalidate, proxy-revalidate")
			c.Header("Pragma", "no-cache")
			c.Header("Expires", "0")
		}

		c.SetBodyStream(file.Reader, int(file.FileLength))
	} else {
		for k, vs := range file.RespHeader {
			for _, v := range vs {
				c.Header(k, v)
			}
		}

		if rawInline == "true" {
			c.Header("Cache-Control", "private")
			c.Header("Content-Disposition", mime.FormatMediaType("inline", map[string]string{
				"filename": file.FileName,
			}))
			c.SetContentType(common.MimeTypeByExtension(file.FileName))
		}

		c.SetStatusCode(file.StatusCode)
		c.SetBodyStream(file.ReadCloser, int(file.FileLength))
	}
}
