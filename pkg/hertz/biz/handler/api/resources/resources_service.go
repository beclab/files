// Code generated by hertz generator.

package resources

import (
	"context"
	"encoding/json"
	"files/pkg/common"
	"files/pkg/drivers"
	"files/pkg/drivers/base"
	"files/pkg/drivers/sync/seahub"
	"files/pkg/hertz/biz/dal/database"
	resources "files/pkg/hertz/biz/model/api/resources"
	"files/pkg/hertz/biz/model/api/share"
	"files/pkg/models"
	"fmt"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"k8s.io/klog/v2"
	"strings"
)

// GetResourcesMethod .
// @router /api/resources [GET]
func GetResourcesMethod(ctx context.Context, c *app.RequestContext) {
	contextArg, err := models.NewHttpContextArgs(ctx, c, "/api/resources", false, false)
	if err != nil {
		klog.Errorf("context args error: %v, path: %s", err, string(c.Path()))
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	klog.Infof("[Incoming-Resource] user: %s, fsType: %s, method: %s, args: %s", contextArg.FileParam.Owner, contextArg.FileParam.FileType, c.Method(), common.ToJson(contextArg))

	var handlerParam = &base.HandlerParam{
		Ctx:   ctx,
		Owner: contextArg.FileParam.Owner,
	}

	var handler = drivers.Adaptor.NewFileHandler(contextArg.FileParam.FileType, handlerParam)
	if handler == nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": fmt.Sprintf("handler not found, type: %s", contextArg.FileParam.FileType)})
		return
	}

	res, err := handler.List(contextArg)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{
			"code":    1,
			"message": err.Error(),
		})
		return
	}

	resp := new(map[string]interface{}) // different disk type with different responses
	if err := json.Unmarshal(res, &resp); err != nil {
		klog.Errorf("Failed to unmarshal response body: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": "Failed to unmarshal response body"})
		return
	}
	c.JSON(consts.StatusOK, resp)
}

// PostResourcesMethod .
// @router /api/resources/*path [POST]
func PostResourcesMethod(ctx context.Context, c *app.RequestContext) {
	contextArg, err := models.NewHttpContextArgs(ctx, c, "/api/resources", false, false)
	if err != nil {
		klog.Errorf("context args error: %v, path: %s", err, string(c.Path()))
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	klog.Infof("[Incoming-Resource] user: %s, fsType: %s, method: %s, args: %s", contextArg.FileParam.Owner, contextArg.FileParam.FileType, c.Method(), common.ToJson(contextArg))

	var handlerParam = &base.HandlerParam{
		Ctx:   ctx,
		Owner: contextArg.FileParam.Owner,
	}

	var handler = drivers.Adaptor.NewFileHandler(contextArg.FileParam.FileType, handlerParam)
	if handler == nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": fmt.Sprintf("handler not found, type: %s", contextArg.FileParam.FileType)})
		return
	}

	_, err = handler.Create(contextArg)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{
			"code":    1,
			"message": err.Error(),
		})
		return
	}

	resp := new(resources.PostResourcesResp)
	c.JSON(consts.StatusOK, resp)
}

// PatchResourcesMethod .
// @router /api/resources/*path [PATCH]
func PatchResourcesMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var req resources.PatchResourcesReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	contextArg, err := models.NewHttpContextArgs(ctx, c, "/api/resources", false, false)
	if err != nil {
		klog.Errorf("context args error: %v, path: %s", err, string(c.Path()))
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	klog.Infof("[Incoming-Resource] user: %s, fsType: %s, method: %s, args: %s", contextArg.FileParam.Owner, contextArg.FileParam.FileType, c.Method(), common.ToJson(contextArg))

	var handlerParam = &base.HandlerParam{
		Ctx:   ctx,
		Owner: contextArg.FileParam.Owner,
	}

	var handler = drivers.Adaptor.NewFileHandler(contextArg.FileParam.FileType, handlerParam)
	if handler == nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": fmt.Sprintf("handler not found, type: %s", contextArg.FileParam.FileType)})
		return
	}

	_, err = handler.Rename(contextArg)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{
			"code":    1,
			"message": err.Error(),
		})
		return
	}

	resp := new(resources.PatchResourcesResp)
	c.JSON(consts.StatusOK, resp)
}

// PutResourcesMethod .
// @router /api/resources/*path [PUT]
func PutResourcesMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var req resources.PutResourcesReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	contextArg, err := models.NewHttpContextArgs(ctx, c, "/api/resources", false, false)
	if err != nil {
		klog.Errorf("context args error: %v, path: %s", err, string(c.Path()))
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	klog.Infof("[Incoming-Resource] user: %s, fsType: %s, method: %s, args: %s", contextArg.FileParam.Owner, contextArg.FileParam.FileType, c.Method(), common.ToJson(contextArg))

	var handlerParam = &base.HandlerParam{
		Ctx:   ctx,
		Owner: contextArg.FileParam.Owner,
	}

	var handler = drivers.Adaptor.NewFileHandler(contextArg.FileParam.FileType, handlerParam)
	if handler == nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": fmt.Sprintf("handler not found, type: %s", contextArg.FileParam.FileType)})
		return
	}

	res, err := handler.Edit(contextArg)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{
			"code":    1,
			"message": err.Error(),
		})
		return
	}

	_ = new(resources.PutResourcesResp) // no response
	c.Header("Etag", res.Etag)
}

// DeleteResourcesMethod .
// @router /api/resources/*path [DELETE]
func DeleteResourcesMethod(ctx context.Context, c *app.RequestContext) {
	var err error
	var req resources.DeleteResourcesReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	var deleteArg = &models.FileDeleteArgs{
		FileParam: &models.FileParam{},
	}
	var p = string(c.Path())
	var path = strings.TrimPrefix(p, "/api/resources")
	if path == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "path invalid"})
		return
	}

	var owner = string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	deleteArg.FileParam, err = models.CreateFileParam(owner, path)
	if err != nil {
		klog.Errorf("file param error: %v, owner: %s", err, owner)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("file param error: %v", err)})
		return
	}

	deleteArg.Dirents = req.Dirents

	klog.Infof("[Incoming-Resource] user: %s, fsType: %s, method: %s, args: %s", deleteArg.FileParam.Owner, deleteArg.FileParam.FileType, c.Method(), common.ToJson(deleteArg))

	if deleteArg.FileParam.FileType == "drive" || deleteArg.FileParam.FileType == "sync" {
		var unsharePaths []string
		for _, dirent := range deleteArg.Dirents {
			if strings.HasSuffix(dirent, "/") {
				unsharePaths = append(unsharePaths, dirent)
			}
		}
		pathQueryParams := &database.QueryParams{}
		pathQueryParams.AND = []database.Filter{}
		database.BuildStringQueryParam(deleteArg.FileParam.Owner, "share_paths.owner", "=", &pathQueryParams.AND, true)
		database.BuildStringQueryParam(deleteArg.FileParam.FileType, "share_paths.file_type", "=", &pathQueryParams.AND, true)
		database.BuildStringQueryParam(deleteArg.FileParam.Extend, "share_paths.extend", "=", &pathQueryParams.AND, true)
		pathQueryParams.OR = []database.Filter{}
		for _, dirent := range unsharePaths {
			database.BuildStringQueryParam(dirent+"%", "share_paths.path", "LIKE", &pathQueryParams.OR, true)
		}
		pathRes, pathTotal, err := database.QuerySharePath(pathQueryParams, 0, 0, "", "", nil)
		if err != nil {
			klog.Errorf("QuerySharePath error: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
		klog.Infof("pathTotal: %d", pathTotal)

		var internalSharePaths []*share.SharePath
		var externalSharePaths []*share.SharePath
		for _, sharePath := range pathRes {
			if sharePath.ShareType == "internal" {
				internalSharePaths = append(internalSharePaths, sharePath)
			} else if sharePath.ShareType == "external" {
				externalSharePaths = append(externalSharePaths, sharePath)
			}
		}

		tokenQueryParams := &database.QueryParams{}
		tokenQueryParams.OR = []database.Filter{}
		for _, sharePath := range externalSharePaths {
			database.BuildStringQueryParam(sharePath.ID, "share_tokens.path_id", "=", &tokenQueryParams.OR, true)
		}
		tokenRes, tokenTotal, err := database.QueryShareToken(tokenQueryParams, 0, 0, "", "", nil)
		if err != nil {
			klog.Errorf("QueryShareToken error: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
		klog.Infof("tokenTotal: %d", tokenTotal)
		for _, shareToken := range tokenRes {
			err = database.DeleteShareToken(shareToken.Token)
			if err != nil {
				klog.Errorf("DeleteShareToken error: %v", err)
				continue
			}
		}

		memberQueryParams := &database.QueryParams{}
		memberQueryParams.OR = []database.Filter{}
		for _, sharePath := range internalSharePaths {
			database.BuildStringQueryParam(sharePath.ID, "share_members.path_id", "=", &memberQueryParams.OR, true)
		}
		memberRes, memberTotal, err := database.QueryShareMember(memberQueryParams, 0, 0, "", "", nil)
		if err != nil {
			klog.Errorf("QueryShareMember error: %v", err)
			c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
			return
		}
		klog.Infof("memberTotal: %d", memberTotal)
		if deleteArg.FileParam.FileType == "sync" {
			for _, sharePath := range internalSharePaths {
				for _, shareMember := range memberRes {
					if sharePath.ID == shareMember.PathID {
						seaResp, err := seahub.HandleDeleteDirSharedItems(sharePath, shareMember, "user")
						if err != nil {
							klog.Errorf("postgres.HandleDeleteDirSharedItems error: %v", err)
							continue
						}
						klog.Infof("postgres.HandleDeleteDirSharedItems response: %+v", seaResp)
					}
				}
			}
		}
		for _, shareMember := range memberRes {
			err = database.DeleteShareMember(shareMember.ID)
			if err != nil {
				klog.Errorf("DeleteShareMember error: %v", err)
				continue
			}
		}

		for _, sharePath := range pathRes {
			err = database.DeleteSharePath(sharePath.ID)
			if err != nil {
				klog.Errorf("DeleteSharePath error: %v", err)
				continue
			}
		}
	}

	var handlerParam = &base.HandlerParam{
		Ctx:   ctx,
		Owner: deleteArg.FileParam.Owner,
	}
	var handler = drivers.Adaptor.NewFileHandler(deleteArg.FileParam.FileType, handlerParam)
	if handler == nil {
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": fmt.Sprintf("handler not found, type: %s", deleteArg.FileParam.FileType)})
		return
	}

	res, err := handler.Delete(deleteArg)
	if err != nil {
		var deleteFailedPaths []string
		if res != nil {
			json.Unmarshal(res, &deleteFailedPaths)
		}
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{
			"code":    1,
			"data":    deleteFailedPaths,
			"message": err.Error(),
		})
		return
	}

	resp := new(resources.DeleteResourcesResp)
	c.JSON(consts.StatusOK, resp)
}
