// Code generated by hertz generator.

package share

import (
	"context"
	"encoding/json"
	"files/pkg/common"
	"files/pkg/hertz/biz/dal/postgres"
	"files/pkg/models"
	"fmt"
	"github.com/cloudwego/hertz/pkg/common/utils"
	"k8s.io/klog/v2"
	"strconv"
	"time"

	share "files/pkg/hertz/biz/model/share"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

// CreateSharePath .
// @router /share/share_path/*path [POST]
func CreateSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.CreateSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	p := "/" + c.Param("path")
	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}
	fileParam, err := models.CreateFileParam(owner, p)
	if err != nil {
		klog.Errorf("file param error: %v, owner: %s", err, owner)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": fmt.Sprintf("file param error: %v", err)})
		return
	}
	if fileParam.FileType != "drive" && fileParam.FileType != "sync" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "file type not supported"})
		return
	}

	expireIn, expireTime := AdjustExpire(req.ExpireIn, req.ExpireTime)

	now := time.Now().UTC().Format(time.RFC3339Nano)

	sharePath := &share.SharePath{
		Owner:       owner,
		FileType:    fileParam.FileType,
		Extend:      common.Md5String(fmt.Sprintf("%s%d", p, time.Now().UnixNano())),
		Path:        p,
		ShareType:   req.ShareType,
		Name:        req.Name,
		PasswordMd5: common.Md5String(req.Password),
		ExpireIn:    expireIn,
		ExpireTime:  expireTime,
		Permission:  req.Permission,
		CreateTime:  now,
		UpdateTime:  now,
	}
	res, err := postgres.CreateSharePath([]*share.SharePath{sharePath})
	if err != nil {
		klog.Errorf("postgres.CreateSharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": err.Error()})
		return
	}

	resp := new(share.CreateSharePathResp)
	resp.SharePath = new(share.ViewSharePath)
	if err = json.Unmarshal(common.ToBytes(res[0]), &resp.SharePath); err != nil {
		klog.Errorf("Failed to unmarshal response body: %v", err)
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "Failed to unmarshal response body"})
		return
	}
	resp.SharePath.SharedByMe = true
	c.JSON(consts.StatusOK, resp)
}

// ListSharePath .
// @router /share/share_path/:node/ [GET]
func ListSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	owner := string(c.GetHeader(common.REQUEST_HEADER_OWNER))
	if owner == "" {
		c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "user not found"})
		return
	}

	queryParams := &postgres.QueryParams{}
	queryParams.AND = []postgres.Filter{}
	postgres.BuildQueryParam(req.PathId, "share_paths.path_id", "=", &queryParams.AND, false)
	postgres.BuildQueryParam(req.Owner, "share_paths.owner", "=", &queryParams.AND, false)
	postgres.BuildQueryParam(req.FileType, "share_paths.file_type", "=", &queryParams.AND, false)
	postgres.BuildQueryParam(req.Extend, "share_paths.extend", "=", &queryParams.AND, false)
	postgres.BuildQueryParam(req.Path, "share_paths.path", "=", &queryParams.AND, false)
	postgres.BuildQueryParam(req.ShareType, "share_paths.share_type", "=", &queryParams.AND, false)
	postgres.BuildQueryParam(req.Name, "share_paths.name", "=", &queryParams.AND, false)

	if req.ExpireIn != 0 {
		currentTime := time.Now()
		expireTime := currentTime.Add(time.Duration(req.ExpireIn) * time.Millisecond).Format(time.RFC3339)
		postgres.BuildQueryParam(expireTime, "share_paths.expire_time", "<=", &queryParams.AND, true)
	}

	joinConditions := []*postgres.JoinCondition{}
	if req.SharedToMe {
		joinConditions = append(joinConditions, &postgres.JoinCondition{
			Table:     "share_paths",
			Field:     "share_paths.id",
			JoinTable: "share_members",
			JoinField: "share_members.share_id",
		})
		postgres.BuildQueryParam(owner, "share_members.share_member", "=", &queryParams.AND, true)
	}
	if req.SharedByMe {
		postgres.BuildQueryParam(owner, "share_paths.owner", "=", &queryParams.AND, true)
	}

	res, total, err := postgres.QuerySharePath(queryParams, 0, 0, "", "", joinConditions)
	if err != nil {
		klog.Errorf("QuerySharePath error: %v", err)
		c.AbortWithStatusJSON(consts.StatusInternalServerError, utils.H{"error": err.Error()})
		return
	}
	klog.Infof("~~~Debug log: QuerySharePath total: %d", total)
	klog.Infof("~~~Debug log: QuerySharePath result: %+v", res)

	resp := new(share.ListSharePathResp)
	resp.Total = int32(total)
	resp.SharePaths = []*share.ViewSharePath{}
	for _, sharePath := range res {
		viewPath := new(share.ViewSharePath)
		if err = json.Unmarshal(common.ToBytes(sharePath), &viewPath); err != nil {
			klog.Errorf("Failed to unmarshal response body: %v", err)
			c.AbortWithStatusJSON(consts.StatusBadRequest, utils.H{"error": "Failed to unmarshal response body"})
			return
		}
		if sharePath.Owner == owner {
			viewPath.SharedByMe = true
		}
		resp.SharePaths = append(resp.SharePaths, viewPath)
	}
	c.JSON(consts.StatusOK, resp)
}

// DeleteSharePath .
// @router /share/share_path/:node/ [DELETE]
func DeleteSharePath(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.DeleteSharePathReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(share.DeleteSharePathResp)

	c.JSON(consts.StatusOK, resp)
}

// GenerateToken .
// @router /share/share_token/:node/ [POST]
func GenerateToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.GenerateTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(share.GenerateTokenResp)

	c.JSON(consts.StatusOK, resp)
}

// RevokeToken .
// @router /share/share_token/:node/ [DELETE]
func RevokeToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.RevokeTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(share.RevokeTokenResp)

	c.JSON(consts.StatusOK, resp)
}

// AddShareMember .
// @router /share/share_member/:node/ [POST]
func AddShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.AddShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(share.AddShareMemberResp)

	c.JSON(consts.StatusOK, resp)
}

// ListShareMember .
// @router /share/share_member/:node/ [GET]
func ListShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.ListShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(share.ListShareMemberResp)

	c.JSON(consts.StatusOK, resp)
}

// UpdateShareMemberPermission .
// @router /share/share_member/:node/ [PUT]
func UpdateShareMemberPermission(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.UpdateShareMemberPermissionReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(share.UpdateShareMemberPermissionResp)

	c.JSON(consts.StatusOK, resp)
}

// RemoveShareMember .
// @router /share/share_member/:node/ [DELETE]
func RemoveShareMember(ctx context.Context, c *app.RequestContext) {
	var err error
	var req share.RemoveShareMemberReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(share.RemoveShareMemberResp)

	c.JSON(consts.StatusOK, resp)
}

//func AdjustExpire(expireIn, expireTime int64) (int64, int64) {
//	currentTime := time.Now().UnixMilli()
//
//	if expireIn == 0 && expireTime == 0 {
//		return 0, 0
//	}
//
//	if expireIn != 0 && expireTime == 0 {
//		return expireIn, currentTime + expireIn
//	}
//
//	if expireIn == 0 && expireTime != 0 {
//		return expireTime - currentTime, expireTime
//	}
//
//	calculatedExpireTime := currentTime + expireIn
//	if calculatedExpireTime > expireTime {
//		return expireIn, calculatedExpireTime
//	} else {
//		return expireTime - currentTime, expireTime
//	}
//}

func AdjustExpire(expireIn int64, expireTime string) (int64, string) {
	currentTime := time.Now()
	currentTimeMillis := currentTime.UnixMilli()

	if expireTime == "" {
		if expireIn == 0 {
			return 0, ""
		}
		return expireIn, currentTime.Add(time.Duration(expireIn) * time.Millisecond).Format(time.RFC3339)
	}

	var expireTimeMillis int64
	if _, err := strconv.ParseInt(expireTime, 10, 64); err == nil {
		val, _ := strconv.ParseInt(expireTime, 10, 64)
		expireTimeMillis = val
	} else {
		parsedTime, err := time.Parse(time.RFC3339, expireTime)
		if err != nil {
			return 0, ""
		}
		expireTimeMillis = parsedTime.UnixMilli()
	}

	if expireIn != 0 {
		calculatedExpireTimeMillis := currentTimeMillis + expireIn
		if calculatedExpireTimeMillis > expireTimeMillis {
			return expireIn, currentTime.Add(time.Duration(expireIn) * time.Millisecond).Format(time.RFC3339)
		}
		return expireTimeMillis - currentTimeMillis, time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
	}

	remaining := expireTimeMillis - currentTimeMillis
	if remaining < 0 {
		return 0, time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
	}
	return remaining, time.Unix(0, expireTimeMillis*int64(time.Millisecond)).Format(time.RFC3339)
}
